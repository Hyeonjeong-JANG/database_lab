.LOG

2023-11-27

마리아디비는 3306포트를 쓴다.(그냥 굳이 바꾸지 마라)

Data - 사실에 대한 것(관찰, 측정 가능)
사실들이 모여서 Information이 된다.

정보화시대
Data 누적하는 프로그램이 필요해짐 -> DBMS

Data 저장 형태 - 표(table)
표로 데이터를 관리하는 방식을 관계형 데이터베이스라고 한다.

CRM 고객의 데이터를 모아서 기업의 이윤을 추구하기 위해 만든 방식

여러 개의 Table을 보관하는 곳이 DataBase, DataBase들을 관리하는 것이 DBMS

자료의 형태(DataType): 숫자(정수, 실수), 문자(기호)
  1) 숫자: 정수(int)
  2) 문자: 문자(char), 문자열(char[ ] - 배열: 물리적으로 연속된 공간에 동일한 형태의 자료가 저장되어 있는 형태) 
* 마리아디비에서는 문자의 자료형을 VARCHAR라고 함
  3) 변수: 변할 수 있는 자료 저장소
  4) 상수: 변할 수 없는 자료 저장소 

* 선임의 방식을 존중하자

2. 지우기(DELETE아님 주의)
  1)  DROP database test00; //삭제됨

구조를 먼저 만들어라. (항목을 써주고, 자료형도 정하고)

SQL(Structured Query Language) - 다른 언어들은 ""을 쓰지만 SQL은 ''를 쓴다.

변수 선언: 자료형 + 변수

순서도 
타원형: 시작, 끝
사각형: 처리(c=a+b)
마름모: 조건식(age >= 20)
육각형: 준비
어떤 수가 짝수인지 홀수인지 알려주는 프로그램을 짠다.
변수명이 좌변에 쓰이면 공간으로 인식, 우변에 쓰이면 값으로 읽는다. 

프로그램 짤 때
*1. 우리말로 설명하기 -> 요구사항 명세
  1) 프로그램을 시작한다.
  2) 정수를 입력받는다.
  3) 입력받은 정수가 홀수인지 짝수인지 판별한다.
    2-1) 홀수면 "홀수"라고 출력한다.
    2-2) 짝수면 "짝수"라고 출력한다.
  4) 프로그램을 종료한다.
 
2. 순서도 작성
3. 코드(C언어 기준으로 적는데 외우진 마라)
int num;
scanf("%d", &num);//num이라는 공간에 d라는 숫자를 집어넣어.
if(num % 2 ==1){
 printf("홀수");
} else{
 printf("짝수");
}

* 이게 맞나요? 말고 다른 방법이 있을까요? 라고 질문하라.

https://ideone.com/

CRUD 꼭 기억하라
Create: 생성 -> 삽입: Insert
Read:  읽기 -> 조회: Select 
Update: 수정 -> 수정: Update
Delete: 삭제 -> 삭제: Delete

1. 테이블 만들기
  1) CREATE database test00;
test00이라는 데이터베이스를 생성

  2) USE test00;
안 해주면 no database selected오류가 뜸.
  3) CREATE TABLE t01(
NAME VARCHAR(30) //이름을 30글자짜리 문자열로 쓰겠다(?)
);

INSERT INTO t01 VALUES(
1, '홍길동'//이렇게 쓰면 일반적으로 순서대로 들어가는데 바꿔서 하고 싶으면 아래처럼 해라.
);

INSERT INTO t01 (NAME, NO) VALUES(
'홍길동', 1//이렇게
);

SELECT NO FROM t01; // t01에서 넘버 항목을 불러줘.
SELECT * FROM t01; // t01의 모든 항목을 불러줘.

CREATE DATABASE tfriends;
USE tfriends;
CREATE TABLE tfriends(
번호 INT,
이름 VARCHAR(30),
전화번호 VARCHAR(11)
);

INSERT INTO tfriends VALUES(
1,'hana', 01012345678
);

CREATE TABLE ttfriends(
num INT,
fname VARCHAR(20),
pohone VARCHAR(11)
);

SELECT * FROM ttfriends;

ALTER TABLE ttfriends CHANGE pohone phone varchar(11) null; 
ALTER TABLE [테이블명] CHANGE [변경전컬럼명] [변경후컬럼명] [속성]; //이렇게 하면 칼럼명을 바꿀 수 있음
https://sangjjang.tistory.com/372
https://kitty-geno.tistory.com/58  MariaDB 사용법

2023-11-28
(복습)
SQL(Structured Query Language)
DBMS(DataBase Management System)
Table + Table  + ... DB
Table = 행 + 열
데이터를 테이블로 표시하는 형식을 '관계형 데이터베이스'라고 함.
CRUD

Create -> Insert
삽입한다. 추가한다. 어디에? 테이블 명을 기술해 준다.
어떤 컬럼에 어떤 데이터를 넣을 거냐?
INSERT INTO 테이블명 (num, name, phone) VALUES
(1,최길동', '01022223333'),
(3, '오길동', '01022223533');

Read -> Select
선택한다. 어디에서? ... 테이블명을 기술해 준다.
SELECT name, phone FROM 테이블명;
전체 테이블의 컬럼이면 SELECT * FROM 테이블명;

Update -> Update
UPDATE 테이블명 SET 컬럼명 = '바꾸고싶은내용' WHERE num = 1;
UPDATE tttfriends SET NO = 2 WHERE NAME = '허허허'; 이런식으로
UPDATE tttfriends SET NAME = '표범', phone = '01088889999'  WHERE NO = 1; //이렇게 합쳐서도 됨.

Delete -> Delete
DELETE FROM tttfriends; //tttfriends의 내용 전부다 지움
DELETE FROM tttfriends WHERE no =1; // tttfriends의 내용 선택해서 지움

*데이터베이스, 테이블 생성 -> CREATE database/table
*데이터베이스, 테이블 삭제 -> DROP database/table

주석은 --

모든 것을 외울 수는 없지만 요정도는 기본이니까 외워라.
그래야 전체적인 프로그램을 머리에 그릴 수 있어서 훨씬 생산성이 높아진다.

-- board TABLE 생성
 CREATE TABLE tb1_board(
 bno INT, -- 이렇게 만들면 사용자가 글번호를 매길 수 있으니까 중복될 수도 있다.
 title VARCHAR(50),// varchar은 50 지정하고 3만 쓰면 3을 차지하지만 char은 50을 다 차지해.
 contents VARCHAR(1000),
 writer VARCHAR(20),
 regdate DATE -- 날짜까지 사용자가 넣으면 1889년 이렇게 넣을지도 모르겠어.
 );
 
DESC tb1_board;

DROP TABLE tb1_board; //삭제하고 다시 해보자.


CREATE TABLE tb1_board(
 bno INT PRIMARY KEY AUTO_INCREMENT,
 -- auto_increment 순서대로 증가한다. primary key 순서대로 증가하니까 중복될 가능성이 없음
 -- primary key 는 정말 중요. 기본키는 null이면 안 돼. 식별할 수 있어야 하니까 기본키는 꼭 설정해야 해.
 title VARCHAR(50),
 contents VARCHAR(1000), -- 제목, 내용은 중복되어서 괜찮아. 기본키로 부적함.
 writer VARCHAR(20), -- 글쓴이도 그래, 여러개 쓸 수도 있으니까.
 regdate DATETIME DEFAULT CURTIME()
 -- 날짜까지 사용자가 넣으면 1889년 이렇게 넣을지도 모르겠어.
 -- 이름 뒤에 괄호가 붙은 애들을 함수라고 불러. CURTIME()
 );
 
DESC tb1_board;

INSERT INTO tb1_board(title, contents, writer)
VALUES ('test title1', 'test contents1', 'user1');
INSERT INTO tb1_board(title, contents, writer)
VALUES ('test title2', 'test contents2', 'user2');
INSERT INTO tb1_board(title, contents, writer)
VALUES ('test title3', 'test contents3', 'user3');

컬럼의 제약조건
primary key: 식별자, 다른 행과 구별되게 해주는 것, 필수, 중복X
 - 필수: not null(반드시 입력받는다), 중복X: unique

함수
함수의 입력부분은 여러개가 될 수도 있고 없을 수도 있지만(괄호는 생략 불가)
출력은 하나만 있어야 하고 혹은 없기도 하다.(안내문 띄우고 뭐 그런 거)

반환하냐 안하냐의 차이는 저장소를 쓰냐 안 쓰냐의 차이인데 println 요런 애들은 그냥 출력이기 때문에 저장소를 쓰지 않고 반환하지 않는다. 

#include <stdio.h>

int add(int n1, int n2){
	int addResult;
	addResult = n1 + n2;
	return addResult;
}

int minus(int n1, int n2){
	int minusResult;
	minusResult = n1 - n2;
	return minusResult;
}

int main(void) {
	// your code goes here
	int a = 5;
	int b = 10;
	int addResultMain = add(a,b);
	int minusResultMain = minus(a,b);
	
	printf("%d\n", addResultMain);
	printf("%d", minusResultMain);
	// return 0;
}

문제1) 두 수가 주어지면 큰 수를 알려주는 함수를 만드시오.(단, 두 수는 같지 않다.)

#include <stdio.h>

int cal(int n1, int n2){
	// if(n1 > n2){
	// 	return n1;
	// } else if(n1 < n2){
	// 	return n2;
	// }
	
	//리턴을 하나만 하고 싶다면?
	int r;
	if(n1>n2){
		r=n1;
	}else{
		r=n2;
	}
	return r;
}

int main(void) {
	int a = 3;
	int b = 7;
	int calMain = cal(a, b);
	printf("%d", calMain);
}


폭포수(요구사항분석 -> 설계 -> 구현 -> 유지보수)

선입후출, 후입선출(stack구조, ex. main은 먼저 실행되더라도 다른 함수들이 끝나야 끝난다.)
선입선출, 후입후출(queue구조, ex. 스케쥴링)

문제2) 숫자를 하나 받아서 그게 2의 배수인지 아닌지를 판별하고 2의 배수면 1을 반환하고 아니면 0을 반환하게 만들어서 메인함수에서 실행시켜라.(2의 배수입니다. 2의 배수가 아닙니다. 라고 출력)

1) 이건 해놓고 보니 리턴값을 반환해서 한 것이 아니었어.
#include <stdio.h>

int cal(int n){
	if(n % 2 == 0){
		printf("짝수입니다.");
	}else{
		printf("홀수입니다.");
	}
}

int main(void) {
	// int a= 17;
	cal(37);
	cal(987);
	cal(370);	
}

2) 하다가 잘 몰라서 쌤이 알려주심.
#include <stdio.h>

int cal2(int n2){
	if(n2%2 == 0){
		return 1;
	} else{
		return 0;
	}
}

int main(void) {
	int r = cal2(9);//계산기에 숫자를 넣어서 리턴값을 받은 다음 그것을 아래와 같이 if문으로 판별하는 것이다.
	if(r == 1){
		printf("짝수입니다.");
	} else{
		printf("홀수입니다.");
	}
	}


3) 쌤이 하신 예시
#include <stdio.h>

int main(void) {
	int num = 14;
	//num에 저장된 값이 2의 배수인지 확인하기
	int result = checkMultiple(num);
	
	//result값이 1이면 2의 배수입니다. 아니면 2의 배수가 아닙니다. 출력
	
	if(result == 1){
		printf("2의 배수입니다.");
	}else{
		printf("2의 배수가 아닙니다.");
	}
	return 0;
	}
	
	int checkMultiple(int n){
		int result;
		if(n % 2 == 0){
			result = 1;
	 }else{
	 	result =0;
	 }
		return result;
	}
//C, JAVA, Python의 형태는 알아두는 것이 좋다(정처기)

문제3) 숫자 세 개를 넣으면 최댓값을 알려주는 함수를 만든다.(단, 세 개의 숫자는 서로 같지 않다.)
*
1. 함수의 형태를 내가 알고 있나?
**매개변수의 개수: 3개, 매개변수의 자료형: 정수(int)
2. 매개변수의 의미를 내가 알고 있나?
3. return  키워드의 역할을 내가 알고 있나?
4. 조건식을 중첩해서 사용할 수 있나? 

#include <stdio.h>

int maxNum(int n1, int n2, int n3){
	if(n1>n2 && n1>n3){
		return n1;
	}else if(n2>n3){
		return n2;
	}else{
		return n3;
	}
}

int main(void) {
	int max = maxNum(3, 9, 17);
	printf("%d", max);
	// if(max == n1){
	// 	printf(n1);
	// } else if( max == n2){
	// 	printf(n2);
	// } else{
	// 	printf(n3);
	// }//이 부분이 안 되는 이유!! n1은 maxNum의 n1이기 때문에 새로 선언해야해. 그런데 또 그러면 완전 다른 n1이 되잖아? 그러면 n1의 주소를 받아와야하는데 그건 나중에 배워보자.
	return 0;
}

문제4)

#include <stdio.h>

// 함수의 이름은 f1이고
// 매개변수는 없습니다.
// 리턴되는 자료도 없습니다.
// 이 함수의 기능은 "Hello" 라는 문자열을 화면에 출력하는 것입니다.

void f1(){
	printf("Hello"); //프린트는 리턴이 아니다.
	return; // 리턴하는 것이 없기 때문에 void가 맞다.
}

char main(void) {
	f1();
	return 0;
}


문제5)
#include <stdio.h>

// 함수의 이름은 f2이고
// 매개변수는 없습니다.
// 리턴되는 자료는 숫자(정수)이고
// 이 함수의 기능은 7을 출력하는 것입니다.

int f2(){

	return 7;
}
int main(void) {
	int r = f2();
	printf("%d",r);
	return 0;
}

문제6)
#include <stdio.h>

// 함수의 이름은 f2이고
// 매개변수는 없습니다.
// 리턴되는 자료는 숫자(정수)이고
// 이 함수의 기능은 7을 출력하는 것입니다.

int f2(int n1, int n2){

	return n1 + n2;
}
int main(void) {
	int r = f2(1,2);
	printf("%d",r);
	return 0;
}

문제7)
#include <stdio.h>

// 함수의 이름은 f3이고
// 매개변수의 개수는 1개입니다.
// 매개변수는 정수자료를 저장합니다.
// 이 함수의 기능은 매개변수를 제곱한 값을 리턴하는 것입니다.

int f3(int n1){
	return n1*n1;
}

int main(void) {
	int r = f3(3);
	printf("%d", r);
	return 0;
}

2023-11-29

학생테이블 만들기
테이블 명: tb1_students
필드(컬럼)명
1. 번호: sno - int - 자동증가
2. 이름: sname - varhar(20)
3. 학년: grade - char(1)
4. 반: class - char(1)
5. 국어점수: kor_score - int
6. 영어점수: eng_score - int
7. SQL점수: sql_score - int

CREATE database Students;
USE Students;
CREATE TABLE tb1_students(
sno INT PRIMARY KEY AUTO_INCREMENT, 
-- varchar(30)과 같이 int의 옆에 괄호로 숫자를 채워 넣지 않는다면 DESC 해서 봤을 때 자동으로 int(11)이 되어 있다.
-- 지정해야 한다면 지정해도 된다.
sname VARCHAR(20),
grade CHAR(1),
class CHAR(1),
kor_score INT,
eng_score INT,
sql_score INT 
);
SELECT * FROM tb1_students;
DESC tb1_students;

INSERT INTO tb1_students (sname, grade, class, kor_score, eng_score, sql_score)
VALUES('John', '1', '1', 70, 80, 90);//이렇게 하나씩 해도 오키

INSERT INTO tb1_students (sname, grade, class, kor_score, eng_score, sql_score)
VALUES
('Ann', '1', '1', 80, 80, 90),
('Kane', '2', '1', 20, 80, 90),
('Hong', '2', '1', 30, 70, 90),
('Kang', '2', '2', 40, 60, 90),
('Choi', '2', '2', 50, 80, 90),
('Jeong', '1', '2', 60, 80, 90),
('Oh', '1', '1', 70, 90, 90),
('Park', '1', '2', 80, 90, 90),
('Lee', '3', '1', 90, 60, 90),
('Seo', '3', '1', 100, 80, 90)
;//이렇게 한 번에 해도 오키
SELECT COUNT(*) FROM tb1_students;
SELECT COUNT(sname) FROM tb1_students; -- sname의 개수를 구해라.
SELECT COUNT(sno) AS 학생수 FROM tb1_students; -- as  학생수 해서 별칭을 부여한다. as를 생략해도 된다.
SELECT COUNT(sno) 학생수 FROM tb1_students;

-- create table 할 때 들여쓰기 등을 잘 지켜서 가독성이 좋게 만들어라. 나열해서 쓰면 별로임. 협업할 때 엄청 중요함.

INSERT INTO tb1_students (sname, grade, class, kor_score, eng_score, sql_score)
VALUES (NULL, '4', '1', 70, 80, 90);
SELECT COUNT(*) FROM tb1_students; -- 학생 이름을 null로 해도 학생수는 늘지만
SELECT COUNT(sname) FROM tb1_students; -- 학생 이름을 카운트 할 때는 들어가지 않는다.

-- 1. 1학년 학생들의 이름과 학년, 반을 조회하시오.
SELECT sname, grade, class FROM tb1_students WHERE grade = '1';

-- 2. 국어 점수가 70점을 초과한 학생들의 이름, 학년을 조회하시오.
SELECT sname, grade FROM tb1_students WHERE kor_score > 70;

-- 3. 영어 점수가 65점~75점인 학생의 이름을 조회하시오.
SELECT sname FROM tb1_students WHERE 65<=eng_score AND eng_score<=75; -- between도 있음.
//이거 분명 했는데 왜 안 되지, 이건 됨. 오타났던듯. 아니안됨. and 하니까 안 됨ㅠㅠ


INSERT INTO tb1_students (sname, grade, class, kor_score, eng_score, sql_score)
VALUES
('김철수', '3', '2', 65, 75, 80),
('김동수', '3', '1', 65, 65, 70),
('김희선', '3', '2', 65, 85, 60),
('나철수', '3', '1', 65, 95, 50),
('한철수', '3', '2', 65, 35, 40),
('마동석', '3', '1', 65, 55, 80)
;

SELECT * FROM tb1_students;

-- 특정 단어가 들어있는 자료를 찾는 방법
-- SELECT * FROM tb1_students WHERE sname = '김'; -- 김이라는 이름은 없어서 안 나옴.
SELECT * FROM tb1_students WHERE sname = '김철수';
SELECT * FROM tb1_students WHERE sname LIKE '김%';
SELECT * FROM tb1_students WHERE sname LIKE '%수';

-- 4. 이름이 null인 학생을 조회하시오.
-- SELECT * FROM tb1_students WHERE sname = NULL; -- 이거안됨
SELECT * FROM tb1_students WHERE sname IS NULL; -- 정처기 시험칠 때 헷갈리지 않게 주의해야 해.

-- 총점을 구해보려 해.
SELECT *, kor_score + eng_score + sql_score AS 총점 FROM tb1_students;

SELECT sname, kor_score FROM tb1_students ORDER BY kor_score DESC;-- 내림차순
SELECT sname, kor_score FROM tb1_students ORDER BY kor_score ASC;-- 오름차순

-- 5. 학생들의 국어, 영어, sql 총점을 구해서 총점이 가장 높은 학생순으로 정렬하시오. 
SELECT *, kor_score + eng_score + sql_score AS 총점 FROM tb1_students ORDER BY 총점 DESC;

SELECT * FROM tb1_students WHERE sname LIKE '_동%'; -- 이렇게 하면 마석동 안 안옴.
SELECT * FROM tb1_students WHERE sname LIKE '%동%'; -- 이렇게 하면 마석동도 나옴.
-- 쌤 너무 웃김ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
-- 매일 30분 씩 수학에 대한 공부를 하는 것이 좋다. 수학적인 사고를 할 수 있도록!!

-- 마동석을 마석동으로 바꾸자
UPDATE tb1_students SET sname = '마석동' WHERE sno = 18;

-- 조회결과가 최, 정, 서씨만 나오게 조회를 해보자.
SELECT * FROM tb1_students WHERE sname LIKE '__o%'; -- 세 번째 o가 있다는 공통점, 그런데 o뒤에 %를 하지 않으면 Seo만 나와.

-- 6. 이름이 null인 학생의 모든 데이터를 삭제하시오.
DELETE FROM tb1_students WHERE sname IS NULL;

-- 7. 국어점수가 65점인 학생들의 국어점수를 +5점하시오.
UPDATE tb1_students SET kor_score = 70 WHERE kor_score = 65; -- 이렇게하면안됨.
UPDATE tb1_students SET kor_score = kor_score+5 WHERE kor_score =65;

SELECT * FROM tb1_students;

-- 최고점, 최저점을 찾는 방법
SELECT MAX(kor_score) FROM tb1_students;
SELECT MIN(kor_score) FROM tb1_students;

-- 8. 국어점수가 최고인 학생의 이름을 조회하시오.
SELECT sname, kor_score FROM tb1_students WHERE kor_score =(SELECT MAX(kor_score) FROM tb1_students);

-- 9. 국어점수가 최저인 학생의 이름을 조회하시오.
SELECT sname, kor_score FROM tb1_students WHERE kor_score =(SELECT MIN(kor_score) FROM tb1_students);

-- 하다가 너무 모르겠으면 한 줄로 구현하려 하지 말고 두 줄, 세 줄로 구현해라.
-- 서브쿼리

C언어와 자바의 차이점(제대로 적지 못 함, 찾아보고 정리하자)
C언어의 '구조체' - 동일한 타입의 데이터가 아니어도 서로 같이 저장될 수 있음(이형의 데이터)
배열은 물리적으로 연속된 공간에 동일한 타입의 자료가 저장됨
배열은 연산 처리가 정말 빠르지만 제한적이다.
프로그램은 이형의 데이터들의 집합으로 돌아간다.
자바는 구조체는 없지만 class라는 머시기로 이루어져있다.
C언어의 구조체에는 변수만 들어갈 수 있다.

함수에 대해 이야기 해보자.
float 실수 
double 실수(x.x), 근사치를 나타낼 때.
int 정수
short 정수
char 문자

https://ideone.com/
문제 1)
#include <stdio.h>
// 세 개 과목의 총점을 구하는 함수

int totalScore(int score1, int score2, int score3){
	return score1 + score2 + score3;
}

int aveScore(int score1, int score2, int score3){
	return (score1 + score2 + score3) / 3;
}


int main(void) {
	int a = 88;
	int b = 93;
	int c = 89;
	int totalResult = totalScore(a, b, c);
	printf("총점은 %d 이다.", totalResult);
	int aveResult = aveScore(a, b, c);
	printf("평균은 %d 이다.", aveResult);
	return 0;
}

문제2)
#include <stdio.h>

double f1(double n1, double n2, double n3){
	double avg = (n1 + n2 + n3) / (3*1.0);
	return avg;
}
double main(void) {
	double r = f1(34.5,56.4,78.0);
	printf("%lf", r);// double을 쓸 때는 %lf를 쓴다.
	return 0;
}

문제3)
#include <stdio.h>

int f3(int n1, double n2){
	int y;
	y=n1 + n2;
	return y;
}
int main(void) {
	int x;
	x=f3(10, 1.5);
	printf("%d", x);
	return 0;
}

문제4)
#include <stdio.h>
char f4(int i){
	char c;
	c = 'g'; //char 에는 홑따옴표를 써서 문자 하나만 들어간다.
	return c;	
}

int main(void) {
	
	char tf;//문자 하나를 저장할 수 있는 tf를 만든다.
	tf = f4(72);
	printf("%c", tf);//char은 d가 아니라 c
	return 0;
}//이거 다시 정리해보자.

문제5)
#include <stdio.h>
//기준 점수가 60점 이상이다. 참, 거짓. 합격이면 O, 불합격이면 X라고 하자.

char f(int score){
	char result;
	if(score >= 60){
		result = 'O';
	}else{
		result = 'X';
	}
	return result;
}

char main(void) {
	char result = f(59);
	//printf("%c", result);
	if(result == 'O'){
		printf("합격입니다.");
	}else{
		printf("불합격입니다.");
	}
	return 0;
}

문제6)
#include <stdio.h>
// 1. 매개변수가 없다.
// 2. 함수는 안녕 이라는 것만 말한다. 

void hello(){
	printf("hello");
	return;
}
char main(void) {
	hello();
	return 0;
}

문제7)
#include <stdio.h>
//매개변수  M A N 모닝 애프터눈 나이트
// 굿모닝 굿애프터눈 굿나잇 출력하는 함수

char hi(char c){
	char h;
	if(c == 'M'){
		h = 'M';
	}else if(c == 'A'){
		h = 'A';
	}else{
		h = 'N';
	}
	return h;
}
char main(void) {
	char h = hi('M');
	if(h == 'M'){
		printf("굳모닝");
	}else if(h == 'A'){
		printf("굳애프터눈");
	}else{
		printf("굳나잇");
	}
	return 0;
}

문제8)
#include <stdio.h>

int f2(int n){
	return n*n;
}

int f1(int n){
	int r = f2(n);
	return r;
}

int main(void) {
	int x = f1(5);
	int y = f2(5);
	printf("%d", x);
	printf("%d", y);
	return 0;
}


값을 저장할 수 있는 공간과 주소값을 저장(참조변수)할 수 있는 공간이 따로 있다.
int *p; -> p라는 애는 주소값을 저장하는 용도로 쓸겁니다 라는 뜻.
이때는 p=10; 이런거 안 되고 p=&n;이런거 됨. 그러면 p에 팔이 생겨서 n의 주소 값으로 찾아가.

2023-11-/30
https://github.com/datacharmer/test_db 다운받아서 실습함
마리아디비>빈 경로를 패스 환경설정에 넣어줌
C:\>mariadb -u root -p
여기서 비번 1234 쳐줌

///////////////////////이렇게도 해보고
MariaDB [(none)]> use test00;
Database changed
MariaDB [test00]> show tables;
+------------------+
| Tables_in_test00 |
+------------------+
| board            |
| students         |
| t01              |
| tb1_board        |
| tb2_students     |
+------------------+
5 rows in set (0.000 sec)

MariaDB [test00]>

//////////////////////////이렇게도 해봄
MariaDB [test00]> desc tb1_board;
+----------+---------------+------+-----+-----------+----------------+
| Field    | Type          | Null | Key | Default   | Extra          |
+----------+---------------+------+-----+-----------+----------------+
| bno      | int(11)       | NO   | PRI | NULL      | auto_increment |
| title    | varchar(50)   | YES  |     | NULL      |                |
| contents | varchar(1000) | YES  |     | NULL      |                |
| writer   | varchar(20)   | YES  |     | NULL      |                |
| regdate  | datetime      | YES  |     | curtime() |                |
+----------+---------------+------+-----+-----------+----------------+
5 rows in set (0.012 sec)

MariaDB [test00]>

//////////////////요것도
MariaDB [test00]> select * from tb1_board;
+-----+-------------+----------------+--------+---------------------+
| bno | title       | contents       | writer | regdate             |
+-----+-------------+----------------+--------+---------------------+
|   1 | test title1 | test contents  | user1  | 2023-11-28 11:00:39 |
|   2 | test title3 | test contents3 | user3  | 2023-11-28 11:00:57 |
|   3 | test title2 | test contents2 | user2  | 2023-11-28 11:01:08 |
+-----+-------------+----------------+--------+---------------------+
3 rows in set (0.000 sec)

MariaDB [test00]>

////////////////////테이블 만들고 바이
MariaDB [test00]> create table t02(
    -> c1 int,
    -> c2 char(2),
    -> );
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ')' at line 4
MariaDB [test00]> create table t02(
    -> c1 int,
    -> c2 char(2)
    -> );
Query OK, 0 rows affected (0.007 sec)

MariaDB [test00]> desc t02;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| c1    | int(11) | YES  |     | NULL    |       |
| c2    | char(2) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.013 sec)

MariaDB [test00]> exit
Bye

C:\>

////////////////////////실습
////////////////////////////테이블 조회하고 개수 세기

MariaDB [employees]> show tables;
+----------------------+
| Tables_in_employees  |
+----------------------+
| current_dept_emp     |
| departments          |
| dept_emp             |
| dept_emp_latest_date |
| dept_manager         |
| employees            |
| salaries             |
| titles               |
+----------------------+
8 rows in set (0.000 sec)

MariaDB [employees]> select count(*) from employees;
+----------+
| count(*) |
+----------+
|   300024 |
+----------+
1 row in set (0.027 sec)

MariaDB [employees]>

/////////////////////////////////테이블 보기
MariaDB [employees]> desc employees;
+------------+---------------+------+-----+---------+-------+
| Field      | Type          | Null | Key | Default | Extra |
+------------+---------------+------+-----+---------+-------+
| emp_no     | int(11)       | NO   | PRI | NULL    |       |
| birth_date | date          | NO   |     | NULL    |       |
| first_name | varchar(14)   | NO   |     | NULL    |       |
| last_name  | varchar(16)   | NO   |     | NULL    |       |
| gender     | enum('M','F') | NO   |     | NULL    |       |
| hire_date  | date          | NO   |     | NULL    |       |
+------------+---------------+------+-----+---------+-------+
6 rows in set (0.008 sec)

MariaDB [employees]>

///////////////////성별로 그룹을 지어서 남자, 여자 수 알아보기
MariaDB [employees]> select gender, count(gender) from employees group by gender;
+--------+---------------+
| gender | count(gender) |
+--------+---------------+
| M      |        179973 |
| F      |        120051 |
+--------+---------------+
2 rows in set (0.052 sec)

MariaDB [employees]>



SELECT * FROM tb2_students;
SELECT grade, SUM(kor_score)
FROM tb2_students
GROUP BY grade; 
-- 학년별로 그룹을 묶어서 국어점수의 합을 적인 것이다. 집계함수를 선언할 때 그룹별로 할 수 있다.

SELECT grade, SUM(kor_score)
FROM tb2_students
WHERE grade = '3'
GROUP BY grade;

SELECT grade, SUM(kor_score)
FROM tb2_students

GROUP BY grade;


USE employees;
SELECT gender, COUNT(gender) 
FROM employees GROUP BY gender 
HAVING COUNT(gender) > 130000;

CREATE TABLE student(
stu_no CHAR(9) PRIMARY KEY, -- not null은 안 적어줘도 그냥 primary key 하면 적용된다.
stu_name VARCHAR(20) NOT NULL,
stu_dept VARCHAR(20) NOT NULL,
stu_grade CHAR(1) CHECK(stu_grade IN('1', '2', '3')),
stu_class CHAR(1) ,
stu_gender CHAR(1) CHECK(stu_gender IN('M', 'F')),
stu_height INT DEFAULT 0 CHECK(stu_height < 300),
stu_weight INT DEFAULT 0
);
-- default(기본값): 체중, 신장은  0
-- check(제약조건): 1, 2, 3학년까지만 존재 / 성별은 M: 남자, F: 여자
SELECT * FROM student;
DROP

INSERT INTO student VALUES 
('20153075', '옥한빛', '기계', '1', 'C', 'M', 177, 80);
INSERT INTO student 
VALUES 
('20153088', '이태연', '기계', '1', 'C', 'F', 162, 50),
('20143054', '유가인', '기계', '2', 'C', 'F', 154, 47),
('20152088', '조민우', '전기전자', '1', 'C', 'M', 188, 90),
('20142021', '심수정', '전기전자', '2', 'A', 'F', 168, 45),
('20132003', '박희철', '전기전자', '3', 'B', 'M', NULL, 63),
('20151062', '김인중', '컴퓨터정보', '1', 'B', 'M', 166, 67),
('20141007', '진현무', '컴퓨터정보', '2', 'A', 'M', 174, 64),
('20131001', '김종헌', '컴퓨터정보', '3', 'C', 'M', NULL, 72),
('20131025', '옥성우', '컴퓨터정보', '3', 'A', 'F', 172, 63)
;

-- 1-1. 학생 테이블에서 학과명을 조회하시오.
SELECT stu_dept FROM student;
-- 1-2. 학생 테이블에서 학과명으 조회하시오.(단 중복된 자료를 제외합니다.)
SELECT DISTINCT stu_dept AS 전공 FROM student;
SELECT stu_dept AS 전공 FROM student GROUP BY stu_dept;

-- 2. 학생테이블엥서 '컴정'학과 2학년 학생으 이름, 학과, 학년, 반을 조회하시오.
SELECT stu_name, stu_dept, stu_grade, stu_class FROM student WHERE stu_dept = '컴퓨터정보' AND stu_grade = '2';

-- 3. 학생 테이블에서 체중이 60키로 이상이고 70키로 이하인 학생들의 모든 정보를 조회하시오.
SELECT * FROM student WHERE stu_weight>=60 AND stu_weight<=70;

-- 4. 학생테이블에서 학번, 이름을 조회할 때 조 회결과 열의 제품이 ID, NAME으로 표시되도록 하시오.
SELECT stu_no AS ID, stu_name AS NAME FROM student;

-- 5. 2014학번 학생의 정보를 검색하시오.
SELECT * FROM student WHERE stu_no LIKE '2014%';

-- 6. 성이 김씨인 학생들의 정보를 검색하시오.
SELECT * FROM student WHERE stu_name LIKE '김%';

-- 7. 학생 중 이름의 두번째 문자가 '수'인 학생의 이름을 검색하시오.
SELECT stu_name FROM student WHERE stu_name LIKE '_수_';

-- 8-1. 학과가 컴퓨터 정보이거나 기계과인 학생의 학번과 이름을 검색하시오.
SELECT stu_no, stu_name, stu_dept FROM student WHERE stu_dept = '컴퓨터정보' OR stu_dept = '기계';

-- 8-2. 학과가 컴퓨터 정보이거나 기계과인 학생의 학번과 이름을 검색하시오.
SELECT stu_no, stu_name, stu_dept FROM student WHERE stu_dept IN('컴퓨터정보', '기계');

-- 9. 학생의 키 정보가 null인 학생의 학번, 이름, 키 정보를 조회하시오.
SELECT stu_no, stu_name, stu_height FROM student WHERE stu_height IS NULL;

-- 10. 학생의 키 정보가 null이 아닌 학생의 학번, 이름, 키 정보를 조회하시오.
SELECT stu_no, stu_name, stu_height FROM student WHERE stu_height IS NOT NULL;

-- 11. 학과별 몸무게 평균
-- 사람수를 구한다. 
SELECT COUNT(stu_name) FROM student  GROUP BY stu_dept;
-- 몸무게의 합을 구한다.
SELECT SUM(stu_weight) FROM student GROUP BY stu_dept;
SELECT stu_dept,  SUM(stu_weight) / COUNT(stu_name) AS 몸무게평균 FROM student WHERE stu_weight GROUP BY stu_dept;
-- 이건avg 함수를 활용한 것! ave가 아니라 avg였다ㅋㅋㅋ
SELECT stu_dept, AVG(stu_weight) AS 몸무게평균 FROM student GROUP BY stu_dept;



문제1)
#include <stdio.h>
int res1(){
	int n = 4;
	return n;	
}

int res2(){
	int n = 30;
	return 	n + res1();
}

int res3(){
	int n = 200;
	return n + res2();
}

int main(void) {
	// int n = res3();
	// printf("%d", n);
	printf("%d", res3());// 이 방법은 초심자에겐 권장하진 않음.
	return 0;
}


반복문( while, for...)
for문은 반복 횟수를 알고 있을 때
while문은 무한루프나 특정 조건을 만족할 때까지 반복하는 경우에 사용
while문은 조건식의 결과가 true일 때만 반복문이 작동하는거야. false가 되면 반복문이 끝나. 

함수를 만들 때는 main함수 밖에도 쓸 수 있지만 if, while 이런 애들은 함수 안에다 써야해.

문제2)
#include <stdio.h>

int main(void) {
	 int n = 1;
	
	 while(n <= 10){
	 	printf("%d. ", n);
	 	printf("안녕하세요.\n");
	 	n++;//조건문 안에는 return을 하지 않아.
	 	//조건문 안에서의 순서도 중요. 
	 }
	return 0;
}

문제3)
#include <stdio.h>

int main(void) {
	int n;//C언어에서는 for문 밖에 n을 미리 선언해 놓는다.
	for(n=1; n<11; n++){
		printf("%d후후\n",n);
	}
	return 0;
}

랜덤함수)
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//랜덤함수 - 가위, 바위, 보 게임 만들기
int main(void) {
	srand(time(0));//이 부분을 while문 안에 넣으면 한 번 생긴 랜덤한 숫자가 열 번 반복된다. 왜냐며 그렇게 만들었으니까.
	int i = 0;
	int num;
	while(i < 10){
		num = rand() % 10+1;//가위바위보게임이면 3+1, 주사위면 6+1.
		printf("rand: %d\n", num);
		i++;
	}
	return 0;
}


문제4-1)
// 컴퓨터가 무슨 숫자를 가지고 있는지 맞추는 게임. 기회는 다섯 번. 컴퓨터가 10이라는 숫자를 가지고 있는데 내가 12라고 하면 더 작은 수를 입력하세요! 이런 식으로.
5번까지 못 맞추면 아쉽네요 이런식으로.(숫자의 범위 - 1~100)

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
	int ans; 
	// 랜덤수를 발생시킨다.
	//반복할 필요 없음 
	srand(time(0));
	int rd_num;
	rd_num = rand() % 10 + 1;
		int i;
	//반복의 시작  
	printf("숫자를 입력하세요");
	for(i = 0; i<5; i++){
		
		// 수를 입력한다.
		scanf("%d", &ans);// 이것이 밖에 있으면 한 번만 실행되고 종료된다. 
		// 입력한 수와 랜덤수를 비교한다.
		if(rd_num == ans){
			printf("정답입니다.");
			break;
		} else{
			if(rd_num > ans){
				printf("기회는 %d 번 더 남았습니다. 더 큰 수를 입력하세요.", 4-i);
			} else{
				printf("기회는 %d 번 더 남았습니다. 더 작은 수를 입력하세요.", 4-i);
			}
		}
	}
	// 수를 맞추라고 안내문이 나온다.
	// 반복의 끝
	  
	// 같으면 축하메시지를 보여주고 종료 한다.
	// 입력한 수가 작으면 작다고 알려준다.
	// 입력한 수가 크다면 크다고 알려준다.
	
	// 다시 수를 입력하라고 안내한다.
	
	// 다시 수를 입력한다. 
	printf("%d", rd_num);
	return 0; 
}


문제4-2)
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 함수를 만들어서 랜덤함수 생성기를 빼내보자!!

int rand_num(){
	
	// 랜덤수를 발생시킨다.
	//반복할 필요 없음 
	srand(time(0));
	int rd_num;
	rd_num = rand() % 10 + 1;
}
 
int main(void) {
    int ans; 
    int rd_num = rand_num();
	int i;
	//반복의 시작  
	printf("숫자를 입력하세요");
	for(i = 0; i<5; i++){
		
		// 수를 입력한다.
		scanf("%d", &ans);
		// 입력한 수와 랜덤수를 비교한다.
		if(rd_num == ans){
			printf("정답입니다.");
			break;
		} else{
			if(rd_num > ans){
				printf("기회는 %d 번 더 남았습니다. 더 큰 수를 입력하세요.", 4-i);
			} else{
				printf("기회는 %d 번 더 남았습니다. 더 작은 수를 입력하세요.", 4-i);
			}
		}
	}
	// 수를 맞추라고 안내문이 나온다.
	// 반복의 끝
	  
	// 같으면 축하메시지를 보여주고 종료한다.
	// 입력한 수가 작으면 작다고 알려준다.
	// 입력한 수가 크다면 크다고 알려준다.
	
	// 다시 수를 입력하라고 안내한다.
	
	// 다시 수를 입력한다. 
	printf("%d", rd_num);
	return 0; 
}

코딩할 때 한글로 먼저 풀어서 상세하게 적은 다음에 하나씩 코딩을 해보자.

2023-12-01
sql 문법 정리 
https://velog.io/@ygh7687/SQL-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC3


데이터 조작어(DML :  Data Manipulation Language)
데이터베이스에 들어 있는 데이터를 조회하거나 검색하기 위한 명령어를 말하는 것으로 RETRIEVE 라고도 함(SELECT)
데이터베이스의 테이블에 들어 있는 데이터에 변형을 가하는 종류(데이터 삽입, 수정, 삭제)의 명령어들을 말함(INSERT, UPDATE, DELETE)
CRUD는 DML!!

데이터 정의어(DDL : Data Definition Language)
테이블과 같은 데이터 구조를 정의하는데 사용되는 명령어들로(생성, 변경, 삭제, 이름변경) 데이터 구조와 관련된 명령어들을 말함.(CREATE, ALTER, DROP, RENAME, 
TRUNCATE)
대략적으로 이렇다고 알면 됨. 

테이블과 같은 데이터 구조를 정의하는데 사용되는 명령어들로 (생성, 변경, 삭제, 이름변경) 데이터 구조와 관련된 명령어들을 말함.

crud 는 dml
https://brownbears.tistory.com/180


-- tb2_students 테이블에서
USE test00;
SELECT * FROM tb2_students;
SELECT * from tb2_students limit 1; -- 조회 결과 행의 수 제한, 왜 쓰는지 모름.

-- 12. 학년별 학생수를 조회하시오.
SELECT grade '학년', COUNT(sno) AS 학생수 FROM tb2_students GROUP BY grade; -- as 말고 ''도 오키,  count(*)이렇게 해도 됨. 학생수는 곧 행의 수니까.
-- 13. 학년, 반별 학생수를 조회하시오.
SELECT grade AS 학년, class AS 반, COUNT(sno) AS 학생수  FROM tb2_students GROUP BY grade, class;
-- 14. 학년, 반별 국어점수의 합계를 조회하시오.
SELECT grade AS 학년, class AS 반, SUM(kor_score) AS 국어점수합계  FROM tb2_students GROUP BY grade, class;
-- 15. 학년, 반별 국어점수, 영어점수, sql점수를 합한 총점을 조회하시오.(내림차순)
SELECT grade AS 학년, class AS 반, SUM(kor_score+eng_score+sql_score) AS 총점 FROM tb2_students GROUP BY grade, class ORDER BY 총점 DESC;
-- 1000점 이상인 구간(?)을 조회하시오.
SELECT grade AS 학년, class AS 반, SUM(kor_score+eng_score+sql_score) AS 총점 FROM tb2_students GROUP BY grade, class HAVING 총점 > 1000 ORDER BY 총점 DESC;
-- GROUP BY는 where이 되지 않기 때문에 having을 써야함. having은 group by 뒤에 씀
-- 16. sql 점수가 최저점인 학생의 이름과 학년, 반을 조회하시오.
SELECT sname AS 이름, grade AS 학년, class AS 반, sql_score AS SQL점수 FROM tb2_students WHERE sql_score = (SELECT MIN(sql_score) FROM tb2_students);
-- 서브쿼리: 쿼리 안의 쿼리(select가 두 개라는 뜻이다.)


-- 회원테이블을 만들어보자!
-- 회원은 어떤 정보가 있으면 좋을까?
-- 기본키는 뭘로 해야 좋을까?

USE test00;
DROP TABLE purple_ocean;
CREATE TABLE purple_ocean(
p_no int PRIMARY KEY AUTO_INCREMENT,
p_name VARCHAR(20) NOT NULL,
p_pw VARCHAR(10) NOT NULL,
p_phone VARCHAR(15) NOT NULL,
p_position VARCHAR(10) CHECK(p_position IN('임원', '정회원', '준회원'))
);
SELECT * FROM purple_ocean;

INSERT INTO purple_ocean (p_name, p_pw, p_phone, p_position)
VALUES ('최치원', '1234', '01011111111', '임원')
;


INSERT INTO purple_ocean (p_name, p_pw, p_phone, p_position)
VALUES 
('김태리', '35794', '01099999999', '정회원')
;

INSERT INTO purple_ocean (p_name, p_pw, p_phone, p_position)
VALUES 
('박지원', '12345', '01022222222', '임원'),
('박혁거세', '7895', '01033333333', '정회원'),
('김춘추', '21321', '01044444444', '정회원'),
('김춘수', '89556', '01055555555', '준회원'),
('이영지', '8523', '01066666666', '준회원'),
('허영지', '12345', '01077777777', '정회원'),
('김알지', '85231', '01088888888', '준회원')
;


CREATE TABLE tbl_users(
id VARCHAR(20) PRIMARY KEY,
pw INT NOT NULL,
NAME VARCHAR(20) NOT NULL,
phone VARCHAR(11) NOT NULL
);

CREATE TABLE tbl_boards(
bno INT AUTO_INCREMENT PRIMARY KEY,
title VARCHAR(100) NOT NULL,
content VARCHAR(1000) NOT NULL,
writer VARCHAR(20),
regdate DATETIME DEFAULT CURTIME(),
FOREIGN KEY (writer) REFERENCES tbl_users(id)
-- 외부키 사용 시 주의점: 외부키로 쓰이는 자료형과 길이를 맞춰야 함. id VARCHAR(20)와 writer VARCHAR(20)의 자료형과 길이를VARCHAR(20)로 맞춰줌.
);

-- DROP table tbl_boards;
INSERT INTO tbl_users (id, pw, NAME, phone)
VALUE 
('호랑이','12345', '박지원', '01022222222'),
( '치타이','7895', '박혁거세','01033333333'),
( '토끼이','21321','김춘추', '01044444444'),
( '뱀뱀','89556','김춘수', '01055555555'),
('펭귄', '8523','이영지', '01066666666'),
('나무늘보', '12345','허영지', '01077777777'),
( '헤헤헤','85231','김알지', '01088888888')
;

INSERT INTO tbl_boards (title, content, writer) 
VALUES 
('가입인사', '반가워요.', '호랑이')
;

-- 외부키를 여러개 연결  가능한가?
SELECT * from tbl_boards;

INSERT INTO tbl_boards (title, content, writer) 
VALUES 
('오늘 정모', '불참합니다.', '펭귄'),
('도서관 모임', '도서관 모임 만듭시다. 장소는 도서관에서 제공할 예정', '헤헤헤')
;

INSERT INTO tbl_boards (title, content, writer) 
VALUES 
('오늘 정모ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ', '불참합니다.', '토끼이'),
; -- 주어진 값을 넘어서면 저장이 되지 않음.

-- 게시물을 조회했는데 아이디 말고 이름도 보고 싶다. 그런데 이름은 외부키로 연결은 되지 않은 상황. join을 할 수 있다.
SELECT * -- u.NAME, b.writer, b.title
FROM tbl_boards b, tbl_users u -- 이렇게 하면 보드를 b로 유저를 u로 줄여서 부를 수 있다. from부터 쓰는 것이 좋은 듯.
WHERE u.id = b.writer AND NAME LIKE '%지%'
ORDER BY phone ASC
;

-- 유저에 등록된 사람만 게시판에 글을 쓸 수 있다.


연습으로 한 번 더 해봄.
CREATE TABLE employees(
empno INT PRIMARY KEY AUTO_INCREMENT,
ename VARCHAR(20),
phone VARCHAR(13),
dept CHAR(4)
);

INSERT INTO employees (ename, phone, dept)
VALUES ('James', '010-1111-1111', '영업');

INSERT INTO employees (ename, phone, dept)
VALUES ('철수', '010-2111-1111', '영업');


SELECT * FROM employees;

CREATE TABLE eboard(
bno INT AUTO_INCREMENT PRIMARY KEY,
title VARCHAR(50),
content VARCHAR(100),
empno INT,
FOREIGN KEY(empno) REFERENCES employees(empno)
);

INSERT INTO eboard (title, content, empno)
VALUES ('제목2', '내용2', 2);

SELECT * FROM eboard;

SELECT * 
FROM  employees em, eboard eb
WHERE em.empno = eb.empno;

다음주에 할 것!!
지금 이 상태에서는 연결된 데이터의 수정이 안 되는데 회원테이블에서 이름이 바뀌면 보드테이블에서도 이름 바뀌게 하는 것을 배운다.




문제1)
// 기호 하나와 숫자 하나를 받는 함수
// 기호를 숫자만큼 찍어서 화면에 출력 

내가 푼 방식->오류남
* 틀린 이유!! 
main함수에 문자열을 쌍따옴표로 감쌈.
//문자일때는 홑따옴표, 문자열일때는 쌍따옴표
void linePrint(char c, int n){
	int i;
	for(i=0; i<n; i++){
		printf("%lf", c);
	}
//	return 0;
} 

char main(){
	linePrint("$",3);//문자일때는 홑따옴표, 문자열일때는 쌍따옴표
	return 0;
}

선생님께서 푼 방식
/*
함수를 만든다. 줄(라인)을 구려주는 함수.
함수이름: linePrint
함수의 입력부(매개변수)의 개수: 2개
1. 기호(문자) 자료를 받을 수 있어야 한다.
-> 해당기호를 화면에 출력하기 위함.
2. 숫자 자료를 받을 수 있어야 한다.
-> 해당기호를 몇 번 화면에 출력할 것인지 정하기 위함. 
*/

void linePrint(char c, int n){
	
	//기능: 매개변수로 들어온 기호를 화면에 출력한다. 
	int i;
	for(i=0; i<n; i++){
		printf("%c", c);
	}
	return;
} 

char main(){// 난 이게 좀 헷갈림, int char 이런거 
	linePrint('$',3);//문자일때는 홑따옴표, 문자열일때는 쌍따옴표
	return 0;
}


///////////이 방법도 있음
void linePrint(char c, int n){
	
	//기능: 매개변수로 들어온 기호를 화면에 출력한다. 
	int i;
	for(i=0; i<n; i++){
		printf("%c", c);
	}
	return;
} 

char main(){
	char c = 'A';
	int n=25;
	linePrint(c, n);//문자일때는 홑따옴표, 문자열일때는 쌍따옴표
	return 0;
}


/////////////이 방법도 있음
void linePrint(char c, int n){
	
	//기능: 매개변수로 들어온 기호를 화면에 출력한다. 
	int i;
	for(i=0; i<n; i++){
		printf("%c", c);
	}
	return;
} 

int main(){
	char c;
	int n;
	
	printf("함수에 넣을 문자를 입력하세요.");
	scanf("%c", &c);
	printf("함수에 넣을 숫자를 입력하세요.");
	scanf("%d", &n);
	
	linePrint(c, n);//문자일때는 홑따옴표, 문자열일때는 쌍따옴표
	return 0;
}



////////////////////10개 넘으면 한 줄에 10개씩
void linePrint(char c, int n){
	
	//기능: 매개변수로 들어온 기호를 화면에 출력한다. 
	int i;
	for(i=0; i<n; i++){
		if(i%10 == 0){
			printf("\n");
		} 
		printf("%c", c);
	} 
//	printf("\n");// 대세에 지장 없음 
	return;
}  

int main(){
	char c;
	int n;
	
	printf("함수에 넣을 숫자를 입력하세요.");
	scanf("%c", &c);
	printf("함수에 넣을 숫자를 입력하세요.");
	scanf("%d", &n);
	
	linePrint(c, n);//문자일때는 홑따옴표, 문자열일때는 쌍따옴표
	return 0;
}


////////////////////////////
#include <stdio.h>
void myPrint(char sign, int x){
	int i;
	for(i=0; i<x; i++){
		printf("%c", sign);
	}
	printf("\n");
}

void myPrint1(){
	printf("========================\n");
}
void myPrint2(){
	printf("************************\n");
}
void myPrint3(){
	printf("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n");
}void myPrint4(){
	printf("##############################");
}

int main(){
	myPrint('=', 20);
	printf("안녕하세요....\n");
	myPrint('*', 20);
	
	printf("\n\n");
	myPrint('&', 30);
	printf("Hello....\n");
	myPrint('#',18);
}
//함수의 생산성!! 유지보수!! 



가위바위보 만들기!!
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//가위바위보게임

// 랜덤수를 저장시켜서 가위바위보 중 하나를 저장한다.
// 컴퓨터에 승점 카운터를 선언한다.

// 컴퓨터가 질문한다.
// 컴퓨터에 하나의 수를 입력한다. 
// 서로 같은 것을 내면 '비겼습니다. 출력하고 승점 카운터에 0을 더함.함 승점 카운터에 1을 더함.
// 내가 가위를 내고, 컴퓨터가 바위를 내면 '메롱' 출력 승점카운터에 0점을 더함.
// 내가 가위를 내고, 컴퓨터가 보자기를 내면 '축하합니다. 출력 승점카운터에 1을 더함.
// 내가 바위를 내고, 컴퓨터가 가위를 내면 '축하합니다. 출력
// 내가 바위를 내고, 컴퓨터가 보자기를 내면 '메롱' 출력 승점 카운터에 0점을 더함.
// 내가 보자기를 내고, 컴퓨터가 가위를 내면 '메롱' 출력 승점 카운터에 0을 더함.
// 내가 보자기를 내고, 컴퓨터가 바위를 내면 '축하합니다. 출력
// 총 다섯 판을 해서 세 판 이상 이긴 사람이 이김.

int random(){
	srand(time(0));
	int com;
	com=rand() % 3+1;
	return com;
} 

int main(){
	int com;	
	com=random();
	//////////////////////////
	// 랜덤수를 저장시켜서 가위바위보 중 하나를 저장한다.
//	int com = random();
//	int rock = 1;
//	int scissors = 2;
//	int paper = 3; 
	// 내가 내는 것에 대한 선언
	int myNum;
	// 컴퓨터에 승점 카운터를 선언한다.
	int myCount = 0;
	int comCount =0;
	// 반복해야 하는 부분  
	int i;
	for(i=0; i<5; i++){
		com=random();
//		printf("랜덤수는 %d", com);
		// 컴퓨터가 질문한다.
		printf("가위바위보!\n");
		// 컴퓨터에 하나의 수를 입력한다. 
		scanf("%d", &myNum);
				
		// 서로 같은 것을 내면 '비겼습니다. 출력하고 승점 카운터에 0을 더함.함 승점 카운터에 1을 더함.
		// 1: 가위, 2: 바위, 3: 보
		if(com == myNum){ 
			printf("랜덤수는 %d", com);
			printf("비겼어! 현재 스코어 -> ");
			myCount = myCount +0; 
			comCount = comCount +0; 
			printf("%d:%d \n", myCount, comCount);
		} else if(com == 1 && myNum == 2){
			printf("랜덤수는 %d", com);
			printf("축하 현재 스코어 -> ");
			myCount = myCount +1; 
			comCount = comCount +0; 
			printf("%d:%d\n", myCount, comCount);
		} else if(com == 1 && myNum == 3){
			printf("랜덤수는 %d", com);
			printf("메롱 현재 스코어 -> ");
			myCount = myCount +0; 
			comCount = comCount +1; 
			printf("%d:%d\n", myCount, comCount);			
		} else if(com == 2 && myNum == 1){
			printf("랜덤수는 %d", com);
			printf("메롱 현재 스코어 -> ");
			myCount = myCount +0; 
			comCount = comCount +1; 
			printf("%d:%d\n", myCount, comCount);						
		} else if(com == 2 && myNum == 3){
			printf("랜덤수는 %d", com);
			printf("축하 현재 스코어 -> "); 
			myCount = myCount +1; 
			comCount = comCount +0;		
			printf("%d:%d\n", myCount, comCount);				
		} else if(com == 3 && myNum == 1){
			printf("랜덤수는 %d", com);
			printf("축하 현재 스코어 -> ");
			myCount = myCount + 1; 
			comCount = comCount +0; 
			printf("%d:%d\n", myCount, comCount);						
		} else if(com == 3 && myNum == 2){
			printf("랜덤수는 %d", com);
			printf("메롱 현재 스코어 -> "); 
			myCount = myCount +0; 
			comCount = comCount +1; 
			printf("%d:%d\n", myCount, comCount);						
		}

		// 내가 가위를 내고, 컴퓨터가 바위를 내면 '메롱' 출력 승점카운터에 0점을 더함.
		// 내가 가위를 내고, 컴퓨터가 보자기를 내면 '축하합니다. 출력 승점카운터에 1을 더함.
		// 내가 바위를 내고, 컴퓨터가 가위를 내면 '축하합니다. 출력
		// 내가 바위를 내고, 컴퓨터가 보자기를 내면 '메롱' 출력 승점 카운터에 0점을 더함.
		// 내가 보자기를 내고, 컴퓨터가 가위를 내면 '메롱' 출력 승점 카운터에 0을 더함.
		// 내가 보자기를 내고, 컴퓨터가 바위를 내면 '축하합니다. 출력
		// 반복은 여기까지 
		// 총 다섯 판을 해서 세 판 이상 이긴 사람이 이김.  
	}
			if(myCount==comCount){
			printf("%d:%d로 비겼습니다.", myCount, comCount);
		} else if(myCount > comCount){
			printf("축하해요!! %d:%d로 이겼습니다.", myCount, comCount);
		} else{
			printf("메롱ㅋ %d:%d로 졌네" , myCount, comCount);
		}
	return 0;
}
















///////////////////////////////////////////////////////만들다 만 것 시작
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//가위바위보게임

// 랜덤수를 저장시켜서 가위바위보 중 하나를 저장한다.
// 컴퓨터에 승점 카운터를 선언한다.

// 컴퓨터가 질문한다.
// 컴퓨터에 하나의 수를 입력한다. 
// 서로 같은 것을 내면 '비겼습니다. 출력하고 승점 카운터에 0을 더함.함 승점 카운터에 1을 더함.
// 내가 가위를 내고, 컴퓨터가 바위를 내면 '메롱' 출력 승점카운터에 0점을 더함.
// 내가 가위를 내고, 컴퓨터가 보자기를 내면 '축하합니다. 출력 승점카운터에 1을 더함.
// 내가 바위를 내고, 컴퓨터가 가위를 내면 '축하합니다. 출력
// 내가 바위를 내고, 컴퓨터가 보자기를 내면 '메롱' 출력 승점 카운터에 0점을 더함.
// 내가 보자기를 내고, 컴퓨터가 가위를 내면 '메롱' 출력 승점 카운터에 0을 더함.
// 내가 보자기를 내고, 컴퓨터가 바위를 내면 '축하합니다. 출력
// 총 다섯 판을 해서 세 판 이상 이긴 사람이 이김.

//가위바위보 한글로 만들기 
char random(){
	srand(time(0));
	int comNum;
	comNum=rand() % 3+1;
	char com;
	if(comNum == 1){
		com = 'c';
	} else if(comNum == 2){
		com = 'q';
	} else{ 
		com = 'w';
	} 
	return com;
} 

int main(){
	
	char s = random();
	printf("%c",s);
	
	return 0;
} 

/*
char main(){ 
	char com;	
	com=random();
	//////////////////////////
	// 랜덤수를 저장시켜서 가위바위보 중 하나를 저장한다.
//	int com = random();
//	int rock = 1;
//	int scissors = 2;
//	int paper = 3; 
	// 내가 내는 것에 대한 선언
	char me;
	// 컴퓨터에 승점 카운터를 선언한다.
	int myCount = 0;
	int comCount =0;
	// 반복해야 하는 부분  
	int i;
	for(i=0; i<5; i++){
		com=random();
		printf("%lf", com);
		// 컴퓨터가 질문한다.
		printf("가위바위보!\n");
		// 컴퓨터에 하나의 수를 입력한다. 
		scanf("%d", &me);
				
		// 서로 같은 것을 내면 '비겼습니다. 출력하고 승점 카운터에 0을 더함.함 승점 카운터에 1을 더함.
		// 1: 가위, 2: 바위, 3: 보
		if(com == me){ 
			printf("랜덤수는 %d", com);
			printf("비겼어! 현재 스코어 -> ");
			myCount = myCount +0; 
			comCount = comCount +0; 
			printf("%d:%d \n", myCount, comCount);
		} else if(com == 1 && me == 2){
			printf("랜덤수는 %d", com);
			printf("축하 현재 스코어 -> ");
			myCount = myCount +1; 
			comCount = comCount +0; 
			printf("%d:%d\n", myCount, comCount);
		} else if(com == 1 && me == 3){
			printf("랜덤수는 %d", com);
			printf("메롱 현재 스코어 -> ");
			myCount = myCount +0; 
			comCount = comCount +1; 
			printf("%d:%d\n", myCount, comCount);			
		} else if(com == 2 && me == 1){
			printf("랜덤수는 %d", com);
			printf("메롱 현재 스코어 -> ");
			myCount = myCount +0; 
			comCount = comCount +1; 
			printf("%d:%d\n", myCount, comCount);						
		} else if(com == 2 && me == 3){
			printf("랜덤수는 %d", com);
			printf("축하 현재 스코어 -> "); 
			myCount = myCount +1; 
			comCount = comCount +0;		
			printf("%d:%d\n", myCount, comCount);				
		} else if(com == 3 && me == 1){
			printf("랜덤수는 %d", com);
			printf("축하 현재 스코어 -> ");
			myCount = myCount + 1; 
			comCount = comCount +0; 
			printf("%d:%d\n", myCount, comCount);						
		} else if(com == 3 && me == 2){
			printf("랜덤수는 %d", com);
			printf("메롱 현재 스코어 -> "); 
			myCount = myCount +0; 
			comCount = comCount +1; 
			printf("%d:%d\n", myCount, comCount);						
		}
		// 내가 가위를 내고, 컴퓨터가 바위를 내면 '메롱' 출력 승점카운터에 0점을 더함.
		// 내가 가위를 내고, 컴퓨터가 보자기를 내면 '축하합니다. 출력 승점카운터에 1을 더함.
		// 내가 바위를 내고, 컴퓨터가 가위를 내면 '축하합니다. 출력
		// 내가 바위를 내고, 컴퓨터가 보자기를 내면 '메롱' 출력 승점 카운터에 0점을 더함.
		// 내가 보자기를 내고, 컴퓨터가 가위를 내면 '메롱' 출력 승점 카운터에 0을 더함.
		// 내가 보자기를 내고, 컴퓨터가 바위를 내면 '축하합니다. 출력
		// 반복은 여기까지 
		// 총 다섯 판을 해서 세 판 이상 이긴 사람이 이김.  

	}
			if(myCount==comCount){
			printf("%d:%d로 비겼습니다.", myCount, comCount);
		} else if(myCount > comCount){
			printf("축하해요!! %d:%d로 이겼습니다.", myCount, comCount);
		} else{
			printf("메롱ㅋ %d:%d로 졌네" , myCount, comCount);
		}
	return 0;
}


*/

///////////////////////////////////////////////////////만들다 만 것 끝

2023-12-04

데이터 정규화 - 표를 쪼갬
데이터 역 정규화 - 쪼개진 표를 합침
역정규화를 하는 이유 - 성능 향상을 위해, 아무래도 너무 쪼깨면 중복의 문제도 있고 그래서 다시 합친다.

의존적이다 = 사용한다!! 나는 망치에 의존적이다. 나는 망치를 사용한다.

schodong.tistory.com

SELECT * from employees;
DROP table employees;

CREATE DATABASE A;
USE A;
CREATE TABLE employees(
empno CHAR(4) PRIMARY KEY,
ename VARCHAR(20),
phone VARCHAR(20),
dept VARCHAR(10) CHECK (dept IN('영업', '인사', '개발'))
);

INSERT INTO employees(empno, ename, phone, dept)
VALUES
('a01', '철수', '01011112222', '영업'),
('c01', '영희', '01022223333', '인사'),
('d01', '철수', '01033334444', '개발')
;

DROP TABLE eboard;
CREATE TABLE eboard(
bno INT PRIMARY KEY AUTO_INCREMENT, 
title VARCHAR(30) NOT NULL, 
content VARCHAR(1000) NOT NULL, 
eno CHAR(4),
FOREIGN KEY(eno) REFERENCES employees(empno)
-- ON UPDATE CASCADE -- 이렇게하면 employees 테이블이 수정되면 eboard에 자동으로 반영됨
-- ON DELETE CASCADE -- 삭제 자동반영
ON DELETE SET NULL -- 삭제하면 null이 되게 해라. 
ON UPDATE CASCADE
);

INSERT INTO eboard (title, content, eno)
VALUES 
('안녕하세요', '안녕하세요. 반갑습니다.' , 'k01'),
('또 안녕', '아무도 대답이 없네...' , 'k01'),
('안녕하세요', '처음뵙겠습니다다.' , 'c01')
;

SELECT e.empno, e.ename, e.phone, b.bno, b.title, b.eno
FROM employees e, eboard b 
WHERE e.empno = b.eno;

SELECT * FROM employees;
SELECT * FROM eboard;

UPDATE employees SET empno = 'w01' WHERE phone = '01011112222';
UPDATE employees SET empno = 'k01' where phone = '01011112222';

DELETE FROM employees WHERE empno = 'c01';
-- 사원게시판 테이블은 사원 테이블에 의존적이다.
-- 이렇게 적으면 지울 수가 없어. 그러면 deleete에 대한 cascade를 설정해주면 된다. 

-- 두 개의 테이블을 서로 연결시켜 주는 것이 외부키
-- 연결시키는 데이터는 유니크하다.
-- 연결시켜서 자동업데이트 하면 cascade를 해서 데이터무결성을 유지하려 한다. 
-- eboard는 삭제할 수 있지만 employees 테이블은 삭제하려면 까다롭다. 


-- 주소 컬럼추가
-- ALTER: 구조 변경
ALTER TABLE employees 
ADD COLUMN address VARCHAR(100);

DESC employees;
SELECT * FROM employees;

ALTER TABLE employees
ADD COLUMN nickname VARCHAR(50) DEFAULT '없음';

-- 생년월일 컬럼을 phone 다음에 추가되게 함.
-- 컬럼의 위치 지정
ALTER TABLE employees
ADD COLUMN birth DATE AFTER phone;

-- 성별 컬럼을 추가하는데 생일 다음에 넣고 자료형은 int
ALTER TABLE employees
ADD COLUMN gender INT AFTER birth;

-- 성별 컬럼의 자료형을 바꿔보기
ALTER TABLE employees
MODIFY COLUMN gender CHAR(1),
MODIFY COLUMN birth CHAR(10) -- 한 번에 여러개로 수정할 수 있음
;

-- 컬럼의 순서를 재배치하기
ALTER TABLE employees
MODIFY nickName VARCHAR(50) AFTER birth; -- 위치를 변경할 컬럼의 자료형까지 써줘야 한다. 

-- 컬럼의 이름을 바꿔보기
ALTER TABLE employees
CHANGE birth birthDate DATE;

-- 컬럼을 삭제하기
ALTER TABLE employees
DROP COLUMN nickName;

-- 테이블 이름을 변경하기
ALTER TABLE eboard RENAME tbl_eboard;

SELECT * FROM tbl_eboard;

CREATE TABLE test(
id VARCHAR(10),
pw VARCHAR(10)
);

DESC test;

-- 테이블의 항목에 속성 추가하기
ALTER TABLE test 
ADD  PRIMARY KEY (id);

-- 테이블의 항목의 속성 삭제하기
ALTER TABLE test
DROP PRIMARY KEY;

ALTER TABLE test
ADD COLUMN empno INT; -- 이렇게 했을때는 employees 테이블과 아무런 관련이 없어.
ALTER TABLE test
MODIFY COLUMN empno CHAR(4); -- 난 char(4)로 했었으니까 int로 하면 잘못되어서 수정.


DESC test;

ALTER TABLE test
ADD FOREIGN KEY(empno) REFERENCES employees(empno);

ALTER TABLE test 
ADD  PRIMARY KEY (empno);



//////////////////////다시 봐도 모르겠으니 내일 묻기
-- 여기서부터 모르겠음
-- 외래키 이름을  알고 싶다면?
ALTER TABLE a.test
DROP FOREIGN KEY test_ibfk_1; -- 요 요상한 키값을 어찌 받는지 알아보기.
SELECT *
FROM information_schema.TABLE_CONSTRAINTS
WHERE TABLE_NAME = 'test';
-- information_schema 데이터베이스이름
-- 여기까지 모르겠음.
-- 내가 모르는 것! 이걸 왜 하는지!!
SELECT * FROM test;



-- 프라이머리 키 관련해서 생각해 볼 내용
-- 우리 마트를 이용하는 고객들을 관리하고 싶어(우수고객, 블랙리스트 등)
-- 회원테이블, 주문테이블을 설계해서 컬럼에 반드시 필수적으로 들어가야 하는 것을 설정하고 키설정까지 하고 나머지는 알아서 해보고

CREATE DATABASE b;
USE b;
DROP TABLE customer;
CREATE TABLE customer (
cNo INT AUTO_INCREMENT PRIMARY KEY,
cName VARCHAR(10) NOT NULL,
cPhone VARCHAR(15) NOT NULL,
cAddress VARCHAR(50)
);

INSERT INTO customer (cName, cPhone, cAddress)
VALUE ('홍길동', '01022223333', '부산시 부산진구');

CREATE TABLE ORDER(
oNo INT AUTO_INCREMENT PRIMARY KEY, 
cName VARCHAR(19),
cPhone VARCHAR(15),
cAddress VARCHAR(50),
oTotalPrice VARCHAR(100)
FOREIGN KEY(cPhone) REFERENCES customer(cPhone)

);
-- 철수가 라면, 과자를 사면 주문번호 1 철수 라면, 주문번호 1 철수 과자


#include <stdio.h>

int main(){
	
	int sign = 2;
	
	switch(sign){
		case 1: printf("1입니다.\n");
		break;
		case 2: printf("2입니다.\n");
		break;
		case 3: printf("3입니다.\n");
		break;
		default: printf("기타등등입니다.\n");
		// 1, 2, 3 외에는 default를 실행해라. 
	}
}



#include <stdio.h>

// 당신이 태어난 월을 말해주세요. -> 탄생석 
// 스위치 케이스를 함수로 만들어보세요.
void findBirthStone(int birthMonth){
//	int birthMonth;

	switch(birthMonth){
		case 1: printf("당신의 탄생석은 가넷입니다. \n");
		break;
		case 2: printf("당신의 탄생석은 자수정입니다. \n");
		break;
		case 3: printf("당신의 탄생석은 아쿠아마린입니다. \n");
		break;
		case 4: printf("당신의 탄생석은 다이아몬드입니다. \n");
		break;
		case 5: printf("당신의 탄생석은 에메랄드입니다. \n");
		break;
		case 6: printf("당신의 탄생석은 진주입니다. \n");
		break;
		case 7: printf("당신의 탄생석은 루비입니다. \n");
		break;
		case 8: printf("당신의 탄생석은 페리도트입니다. \n");
		break;
		case 9: printf("당신의 탄생석은 사파이어입니다. \n");
		break;
		case 10: printf("당신의 탄생석은 오팔입다. \n");
		break;
		case 11: printf("당신의 탄생석은 토파즈입니다. \n");
		break;
		case 12: printf("당신의 탄생석은 터키석입니다. \n");
		break;
//		default: printf("기타등등입니다.\n");
	
	} 
	return 0;
} 

int userInput(){
	int birthMonth;
	printf("당신은 몇 월에 태어났습니까?");
	scanf("%d", &birthMonth); 	
	return birthMonth;
}

int main(){
	
//	int birthMonth;
//	printf("당신은 몇 월에 태어났습니까?");
//	scanf("%d", &birthMonth); 
	
	int birthStone= userInput();
	findBirthStone(birthStone);
	return 0;	
}

//////////////if문으로 바꿔보기

#include <stdio.h>

// 당신이 태어난 월을 말해주세요. -> 탄생석 
// 스위치 케이스를 함수로 만들어보세요.
void findBirthStone(int birthMonth){


	if(birthMonth == 1){
		printf("당신의 탄생석은 가넷입니다. \n");
	} else if(birthMonth == 2){
		printf("당신의 탄생석은 자수정입니다. \n");
	} else if(birthMonth == 3){
		printf("당신의 탄생석은 아쿠아마린입니다. \n");
	} else if(birthMonth == 4){
		printf("당신의 탄생석은 다이아몬드입니다. \n");
	} else if(birthMonth == 5){
		printf("당신의 탄생석은 에메랄드입니다. \n");
	} else if(birthMonth == 6){
		printf("당신의 탄생석은 진주입니다. \n");
	} else if(birthMonth == 7){
		printf("당신의 탄생석은 루비입니다. \n");
	} else if(birthMonth == 8){
		printf("당신의 탄생석은 페리도트입니다. \n");
	} else if(birthMonth == 9){
		printf("당신의 탄생석은 사파이어입니다. \n");
	} else if(birthMonth == 10){
		printf("당신의 탄생석은 오팔니입다. \n");
	} else if(birthMonth == 11){
		printf("당신의 탄생석은 토파즈입니다. \n");
	} else if(birthMonth == 12){
		printf("당신의 탄생석은 터키석입니다. \n");
	} else{
		printf("정확한 월을 입력해 주세요.\n");
	} 
	
	return 0;
} 

int userInput(){
	int birthMonth;
	printf("당신은 몇 월에 태어났습니까?");
	scanf("%d", &birthMonth); 	
	return birthMonth;
}

int main(){

	int birthStone= userInput();
	findBirthStone(birthStone);
	return 0;	
}


//////////////////////구구단
#include <stdio.h>

// 반복문, 배열 
int main(){
	int i, k;
	//i값의 범위: 0, 1, 2 
	for(i = 2; i < 10; i++){
		printf("%d단 \n", i);
		for(k = 1; k < 10; k++){
			printf("%d * %d = %d \n", i, k, i*k);
		}
		printf("\n");
	} 
	return 0;	
}


배열: 연속된 공간에 동일한 타입의 자료가 있는 것
#include <stdio.h>

// 반복문, 배열 
int main(){
	int x[3]; // int x를 세 칸으로 된 배열로 선언한다. int x[만들개수]; 
	x[0] = 100; // x의 0번지에 100을 저장한다. 
	printf("%d", x[0]); 
	
	return 0;	
}

일을 하다가 실수하면 "잘못했습니다." 말고 "주의하겠습니다." 라고 말하라. -> 윤리적으로 잘못한 것은 아니잖아?




#include <stdio.h>

// 1. 정수 자료 3개를 저장할 수 있는 배열을 만드시오. 배열의 이름은 nums로 한다.
// 2. nums 배열의 각 공간에 80, 20, 50이라는 숫자를 순서대로 저장한다. 
// 3. 배열에 저장된 값을 모두 더해서 sum이라는 변수에 저장한다.  
// 4. sum 변수를 출력한다.  
int main(){
////	int nums[3];
////	nums[0] = 80;
////	nums[1] = 20;
////	nums[2] = 50;
//
//	int nums[3] = {80, 20, 50};
//// 배열 안에 있는 값을 차례대로 출력하시오.
//	
////	printf("%d", nums[0]);
//	int i;
//	
//	for(i=0; i<3; i++){
//		printf("%d \n", nums[i]);
//	}	
//	
////	for(i=0; i<nums[].length; i++){
////		printf("%d", nums[i]);
////	}
//
////	int sum = nums[0] + nums[1] + nums[2];
////	printf("%d", sum);

int length = 3;
int nums[length];
nums[0] = 80;
nums[1] = 20;
nums[2] = 50;

int i;
for(i = 0; i<length; i++){
	printf("nums[%d] = %d \n", i, nums[i]);
}
	return 0;	
}


//////////////////// 문제2)


#include <stdio.h>

// 10개의  배열을 저장할 수 있는 것을 만들어서 
// 1. 반복문을 써서 그 안을 채워봐라. 0~9
// 2. 0번 인덱스에는 1, 이렇게 1~10까지가 들어가게 
// 3. 반대로도 해봐라. 
int main(){
	
	//1 - 반복문을 써서 인덱스값과 같은 수를 배열의 값으로 넣어 주기 
	int nums1[10];
	int i;
	for(i=0; i<10; i++){
		nums1[i] = i;
		printf("nums1[%d] = %d\n", i, nums1[i]);
	}
	printf("\n");
	
	//2 - 반복문을 써서 인덱스값보다 1 큰 수를 배열의 값으로 넣어 주기 
	int nums2[10];
	int j;
	for(j=0; j<10; j++){
		nums2[j] = j+1;
		printf("nums2[%d] = %d\n", j, nums2[j]);
	} 
		printf("\n");
		
	//3-1
	int nums3_1[10];
	int k;
	for(k=0; k<10; k++){
		nums3_1[k] = 10-k;
		printf("nums3_1[%d] = %d\n", k, nums3_1[k]);
	}
	
	
	//배열에 scanf를 쓰려면 scanf("%d", x[10]); 
////	3-2
//	int nums3_2[10];
//	int l;
//	for(l=10; l>0; l++){
//		nums3_2[l] = 10-l;
//		printf("nums3_2[%d] = %d\n", l, nums3_2[l]);
//	}
//	printf("\n");

// 로또 번호를 얻어서 배열에 저장
// 1단계: 랜덤수로 6개의 수를 만들어서 배열에 저장한다.
// 2단계: 중복된 숫자가 나오면 제거한다. 
	return 0;	
} 

////////////////////로또번호 생성기

int main(){
	srand(time(0));
	int randNum;
	
	
	int lotto[6];
	int i, j;
	for(i=0; i<6; i++){
		randNum=rand() %45 +1;
		lotto[i]=randNum;
		printf("%d\n", randNum);
		
		// 중복 값이 있으면? 

		for(j=0; j<6; j++){
			if(lotto[j] == lotto[j+1]){
				lotto[i]=randNum;
			} else if(lotto[j] == lotto[j+2]){
				lotto[i]=randNum;
			} else if(lotto[j] == lotto[j+3]){
				lotto[i]=randNum;
			} else if(lotto[j] == lotto[j+4]){
				lotto[i]=randNum;
			} else if(lotto[j] == lotto[j+5]){
				lotto[i]=randNum;
			} 
				
		}// 그런데 이렇게 하면 1번째 이후에는 앞쪽 수를 비교할 수 없다. 

//		for(j=5; j>0; j--){
//			if(lotto[j] == lotto[j-1]){
//				lotto[i]=randNum;
//			} else if(lotto[j] == lotto[j-2]){
//				lotto[i]=randNum;
//			} else if(lotto[j] == lotto[j-3]){
//				lotto[i]=randNum;
//			} else if(lotto[j] == lotto[j-4]){
//				lotto[i]=randNum;
//			} else if(lotto[j] == lotto[j-5]){
//				lotto[i]=randNum;
//			}
//		}
// 위 두 for문을 함수로 나눠서? 

// (0,1 0,2 0,3 0,4 0,5)
// 1,0 (1,2 1,3 1,4 1,5)
// 2,0 2,1 (2,3 2,4 2,5)
// 3,0 3,1 3,2 (3,4 3,5)
// 4,0 4,1 4,2 4,3 (4,5)
// 5,0 5,1 5,2 5,3 5,4 - 5-j
// 0-5까지 하고 5-0까지 또 해줘야해. 
	}
	
	
	return 0;	
}

// 이렇게만 하면 중복되는 숫자가 나와.
// 다시 열심히 해보자. 


2023-12-05

USE test00;

SET @myVal1 = 160; -- 변수 선언
SET @myVal2 = 170;
PREPARE myQuery -- 아래의 from ~; 쿼리문을 마이쿼리로 쓰겠다. 
	FROM 'SELECT * FROM student WHERE stu_height BETWEEN ? AND ?';
EXECUTE myQuery USING @myVal1, @myVal2; 
-- 위 from~;쿼리문의 ? ? 에 세팅된 변수를 넣는다.
-- 이 쿼리는 잘 쓰지 않을 것이다. 그러나 자바로 데이터베이스 연동 프로그램을 짤 때 만나는 클래스 중에 prepare statement 가 있는데 고런 것을 활용할 때 볼 것이다.
 
-- CRUD  중 select만 데이터를 데이터의 변경을 초래하지 않고 조회한다. 나머지는 변경을 함.
-- result set? 이거는 쿼리를 날린 값을 어쩔 때 씀.
-- statement 는 완성된 쿼리를 써야해.
-- prepared statement는 실행 전에 미리 쿼리문을 넣어놓는 것이야. 그래서 완성되지 않은 상태로 되어 있고 완성되지 않는 부분은 ?로 적어놓는다.
-- 나중에 자바할 때 요런 이름이 등장하니까 눈에 발라둬라. 외울 필요는 없다. 

-- LIMIT
SELECT * FROM student ORDER BY stu_height DESC;
SELECT * FROM student ORDER BY stu_height ASC LIMIT 2, 3;
SELECT * FROM student LIMIT 1, 3;
SELECT * FROM student LIMIT 2, 3; -- 2행부터 시작해서 3개의 행을 보여줘라.(시작점은 0행임)
-- 페이지네이션 1페이지에 10개씩 하려면
SELECT * FROM student LIMIT 0, 10; -- 1페이지
SELECT * FROM student LIMIT 10, 10; -- 2페이지
SELECT * FROM student LIMIT 20, 10; -- 3페이지

-- 제어 흐름 함수
SELECT if (100 >200, 'True', 'False') AS tf;
SELECT if (100 <200, 'True', 'False') AS tf;
-- 100<200, true, false 를 인수라고 한다. 함수에서는 매개변수라고 했었음.
-- 함수 호출문에 쓰이는 인수를 실인수
-- 함수 정의문에 쓰이는 인수를 가인수 

SELECT * FROM student;
SELECT IFNULL(NULL, '널이군요.'); -- null 이면 널이군요.
SELECT IFNULL(3, '널임'); -- 첫 번째 인수가 널이 아니면 입력된 값을 출력해 준다.


SELECT stu_height FROM student WHERE stu_no = 20131001; -- 이 값 자체가 널이라서 널이됨

SELECT IFNULL((SELECT stu_height FROM student WHERE stu_no = 20131001), '널이군요'); -- 널이군요
SELECT IFNULL((SELECT stu_height FROM student WHERE stu_no = 20131025), '널이군요'); -- 172 -- 이전에 만들어 놓은 테이블에 입력된 값

SET @v1 = IFNULL((SELECT stu_height FROM student WHERE stu_no = 20131001), '널이군요');
SELECT case @v1
		 when 172 then '172'
		 when 171 then '171'
		 when 173 then '173'
		 ELSE '모름'
END;

SET @v2 = IFNULL((SELECT stu_height FROM student WHERE stu_no = 20131025), '널이군요');
SELECT case @v2
		 when 172 then '172'
		 when 171 then '171'
		 when 173 then '173'
		 ELSE '모름'
END;


SELECT IFNULL(1, '널이군요.'); -- 1을 넣으면 1이 나옴.
-- ifnull 이라는 함수는 널일때만 문장이 출력됨. 널이 아니면 그 값이 출력됨.
SELECT NULLIF(100, 100); -- null
SELECT NULLIF(100, 7); -- 100
SELECT NULLIF(800, 100); -- 800
-- 첫 번째 인수의 값만 나오는데 두 개 인수의 값이 같으면 null이 출력됨.

SELECT case 10
		 when 1 then '일'
		 when 5 then '오'
		 when 10 then '십'
		 ELSE '모름'
END;		 		 		 
		 
-- 디비는 커넥션 스테이트먼트 리절트셋 순서로 진행됨
-- 리절트셋은 셀렉트일때만 사용된다.
-- 그냥 스테이트먼트는 완성된 쿼리를 이용할 때 쓴다.
-- 프리페어스테이트먼트는 미완성된 쿼리를 사용하는데 미완성된 부분은 ?으로 표시한다.
-- 프리페어스테이트먼트가 보안? 보완?에 더 좋다. 보안일 듯.

-- 개발자는 홍익인간이다. 
-- 자소서가 포트폴리오보다 중요하다.

SELECT ASCII('A'); -- 65
SELECT ASCII('C');
SELECT ASCII('Z'); -- 90

SELECT CHAR(65); -- A
-- 65가 A고 A가 65다. 소문자는 또 달라.

-- bit에 저장할 수 있는 값은 1, 0
-- 결국에 데이터에 저장되는 값은 숫자다. 2진수

-- 가중치: 2진수 1의 자리의 가중치는 1, 2의 자리의 가중치는 2,... 1 2 4 8... 1010은 8자리 2자리에 있으니까 10!
-- 이진수 네 자리로 만들 수 있는 최솟값은 0, 최댓값은 15
-- 1 2 4 8을 모두 더하면 15 or 16-1을 하면 15
-- 아스키코드로 표현되는 가장 큰 숫자는 127인데 그 이유가 1바이트가 8비트니까 128-1 해서 127이 된다.

SELECT BIT_LENGTH('abc'); -- 할당된 bit수: 24개
SELECT CHAR_LENGTH('abc'); -- 글자 수: 3개
SELECT LENGTH('abc'); -- 할당된 byte 수: 3byte

SELECT BIT_LENGTH('a'); -- 할당된 bit수: 8개
SELECT CHAR_LENGTH('a'); -- 글자 수: 1개
SELECT LENGTH('a'); -- 할당된 byte 수: 1byte

SELECT BIT_LENGTH('가'); -- 할당된 bit수: 24개
SELECT CHAR_LENGTH('가'); -- 글자 수: 1개
SELECT LENGTH('가'); -- 할당된 byte 수: 3byte

SELECT BIT_LENGTH('곽'); -- 할당된 bit수: 24개
SELECT CHAR_LENGTH('곽'); -- 글자 수: 1개
SELECT LENGTH('곽'); -- 할당된 byte 수: 3byte
-- char_length를 많이 쓴다. 

SELECT CONCAT('abc', '가', 'def', '나'); -- 문자들을 이어서 하나의 문자열로 만들어 준다.
SELECT CONCAT_WS(' - ', '010', '1111', '2222');
SELECT CONCAT_WS(' / ', '2023', '12', '05'); -- 문자열을 이어붙일 때 첫 번째 인수가 사이사이 들어간다.

SELECT ELT(2, 'a', 'b', 'c'); -- b
SELECT ELT(3, 'a', 'b', 'c'); -- c
SELECT ELT(5, 'a', 'b', 'c'); -- null

SELECT FIELD('b', 'a', 'b', 'c');-- 2  첫 번째 인수가 몇 번째 있는지 알려줌. b는 2번째 있다. 

SELECT FIND_IN_SET('b', 'a, b, c'); -- 이건 왜 0을 반환할까?
SELECT FIND_IN_SET('a', 'a, b, c'); -- 하나의 문자열 안에서 첫 번쨰 인수가 몇 번째 글자에 있냐.

SELECT LOCATE('나', '하나둘셋');
SELECT LOCATE('넷', '하나둘셋'); -- 첫 번째 인수가 없으면 0을 반환 있으면 그 순서를 반환

SELECT INSTR('하나둘셋', '넷');
SELECT INSTR('하나둘셋', '셋');

SELECT FORMAT(123456.123456, 2); -- 123456.123456에서 소숫점 두 번째 자리까지 반올림해서 보여줌, 콤마도 찍어줌
SELECT FORMAT(123456.123456, 5); -- 123456.123456에서 소숫점 다섯 번째 자리까지 반올림해서 보여줌, 콤마도 찍어줌
-- format의 설명을 다시 적을 필요가 있음.

SELECT BIN(9);
SELECT BIN(8);
SELECT BIN(4);
SELECT BIN(2);
SELECT BIN(1); -- 10진수를 2진수로 바꿔줌. binary

SELECT OCT(9);
SELECT OCT(8);
SELECT OCT(7);
SELECT OCT(6); -- 10진수를 8진수로 바꿔줌.

SELECT HEX(17); -- 11
SELECT HEX(16); -- 10
SELECT HEX(15); -- F
SELECT HEX(14); -- E
SELECT HEX(13); -- D
SELECT HEX(12); -- C
SELECT HEX(11); -- B
SELECT HEX(10); -- A
SELECT HEX(9); -- 9  -- 10진수를 16진수로 보여줌. -- 표현할 수 있는 숫자가 9까지밖에 없어서 그 이후로는 영어로 적는다. 색상코드 #FFF 이런 것도 16진수다.

-- 2진수로 10진수를 표현하려면 10진수인 수를 2로 나눠서 몫이 0이 될 때까지 계산한 후 거꾸로 써준다.
-- 16진수를 표현하려면 4개의 비트, 8진수를 표현하려면 3개의 비트가 필요하다.
-- 명령창으로 숫자를 입력 받고
-- 8! 2진수로 변화하면 1000
-- 이렇게 출력하는 프로그램을 짜보자.

-- 5A(16) -- 16진수다 --  (5 * 16) + 10 = 90

-- 2진수로 16진수의 수를 표현하려면 한 자리마다 4자리의 비트가 필요하다.
-- 5A -> 
--  0   1  0  1 1 0 1 0
-- 128 64 32 16 8 4 2 1 
-- 1이 표시된 부분을 다 더하면 90! 이게 16진수를 2진수로 바꿔주는 방법

-- 3F ->
-- 3*16 + 15  =  48 +15 = 63

-- 135(8) -> 2진수 -> 10진수
-- 2진수 -> (8진수를 2진수로 표현하라면 한 자리마다 3자리의 비트가 필요하다.)
--  1    3    5
-- 001  011  101 (2)
--       64 32 16 8 4 2 1
-- 0  0   1 0  1  1 1 0 1
-- 64 + 16 + 8 + 4 + 2 + 1 = 93(10)
SELECT OCT(93);

SELECT INSERT('abcdefghi', 1, 2, '@@@@'); -- @@@@cdefghi
SELECT INSERT('abcdefghi', 5, 1, '@@@@'); -- abcd@@@@fghi
SELECT INSERT('abcdefghi', 2, 8, '@@@@'); -- a@@@@
-- 첫 번째 인수의 몇 번째 자리부터 몇 개까지의 것을 지우고 그 자리에 마지막 인수의 것을 집어넣는다.

SELECT LEFT('abcdefg', 3);
SELECT LEFT('abcdefg', 5);
-- 왼쪽에서부터 몇 번째까지를 리턴해라.
SELECT RIGHT('abcdefg', 2); -- fg
-- 오른쪽에서부터 몇 번째까지를 리턴해라.

SELECT RIGHT((SELECT LEFT('abcdefg', 5)), 2); -- de를 리턴하기

SELECT MID('abcdefg', 4, 2); -- 4번째에 있는 것부터 두개를 리턴.
SELECT SUBSTRING('abcdefg', 4, 2); -- 4번째에 있는 것부터 두개를 리턴.
SELECT SUBSTRING('abcdefg' FROM 4 FOR 2); -- 4번째에 있는 것부터 두개를 리턴.

SELECT CONCAT('이것이', SPACE(10), 'MariaDB다'); -- space * 10 해서 중간에 넣어줌.

SELECT REVERSE('abced'); -- 까꾸로
SELECT REPLACE('이것이 MariaDB이다', '이것이', 'This is'); -- 첫 번째 인수의 내용에에서 두 번쨰 인수의 내용을 찾아서 세 번째 인수의 내용으로 바꿔준다.
SELECT LTRIM('          abc              '); -- 왼쪽의 공백을 제거함
SELECT RTRIM('abc          '); -- 오른쪽의 공백을 제거함
SELECT TRIM('          abc          '); -- 왼쪽의 공백만 제거되는데?

SELECT repeat('abc', 3); -- 첫 번째 인수의 내용을 몇 번 반복해라.



지금까지 한 것!!
1. 변수, 선언, 초기화
변수 => 공간
int의 의미
  1) 숫자(정수)다
  2) 4byte다
  
#include <stdio.h>
// 문제1) 시작 x=10, y=5 인데 끝은 x=5, y=10이 되게 하여라.
int main(){
	int x1;
	int y1;
	x1=10;
	y1=5;
	printf("x1: %d, y1: %d \n", x1, y1);
	y1=y1+5;
	x1=y1-5;
	printf("x1: %d, y1: %d \n", x1, y1);
// 이렇게 하면 값이 교체가 되는 것이 아니잖아?
 	int x=5;
 	int y=10;
	int temp=x;
	x=y;
	y=temp;
	printf("%d%d", x, y);
	// 와우 
	return 0;
}

2. 대입, 사칙연산, 나머지 연산
3. 조건 분기 - if, switch
4. 반복 - while, for
5. 함수 정의(선언), 함수 호출
6. 배열 선언, 대입, 반복문 활용

#include <stdio.h>
// continue 
int main(){
	int i;
	for(i=1; i<11; i++){
		if(i % 2 == 0){			
			continue;
		}
		printf("%d", i);
	}
} 

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
// 열 개의 숫자를 저장할 수 있는 배열이 있다. 1~20 
// 그 배열에는 짝수만 들어가야 한다.
// 다 저장이 끝나면 그 배열의 값의 총 합을 구한다. 

int main(){
	int arr[10];
	int num =0;
	int i;
	printf("짝수로만 이루어진 배열\n");
	for(i=1; i<21; i++){
		if(i%2 == 0){
			arr[num] = i;
			printf("%d\n", arr[num]);
			num++;
		} 

	}
	
	int sum;
	for(i=0; i<10; i++){
		sum =  sum + arr[i];
	
	}
	printf("합계 %d\n", sum);	
}



#include <stdio.h>
// 3이 몇 개 들어있냐 
int main(){
	int arr[10] = {10,10,10,3,10,10,3,10,10,3}; 
	int num;
	num=3;
	int i;
	int count=0;
	for(i=1; i<11; i++){		
		if(arr[i] == num){
			count= count+1;
		} 
		
	}	 
	printf("arr배열 안에 %d은 총 %d개 들어있다.\n", num, count);

}  



#include <stdio.h>
// break 
// 정수 열 개를 저장할 수 있는 배열을 arr이라는 이름으로 만든다.  
// 12345678910 들어가게 해라.
// 이 배열 안에 어떤 숫자가 있는지를 알고자 한다. 3이라는 숫자가 배열에 있나? 유무를 판단하고 몇 번째 위치에 있는지 써봐라. 
int main(){
	int arr[10];
	int i;
	int num;
	num=3;
	for(i=1; i<11; i++){
		arr[i]=i;
//		printf("arr[%d] = %d\n", i, arr[i]);
		
		if(arr[i] != num){
//			printf("%d은(는) 이 배열에 없는 수입니다.", num);
//			break; // 함부로 하면 안 돼. 
		} else{			
			printf("%d은(는) 이 배열에 있는 수입니다. %d은(는) 배열의 %d번째에 저장되어 있습니다.",num,num, i); 
			break;
		}
	}	 

}  


#include <stdio.h>
// 선생님 따라하기 
/*
문제: 정수 10개를 저장할 수 있는 배열이 있다.
그 안에 임의의 숫자들이 저장되어 있는데... 그 중에 3이 몇 개 있는지 확인하는 프로그램이다. 
*/
int main(){
	// 1. 정수 10개를 저장할 수 있는 배열이 있어야겠다. 선언하자!!
//	int arr[10];
	// 2. 임의의 숫자들이 저장되어 있다.
//	arr[0]=102;
//	arr[2]=1003; 
	// 귀찮다. 배열의 초기화를 이용하자. 
	int arr[10]= {0,0,0,3,0,3,3,3,0,0}; 
	// 3이 몇 번째에 저장되어 있는가? 알고 싶다면 3이 나타날 때마다 저장해놔.
	// 3은 10번 들어있을 수 있으니 10개짜리 배열을 선언해
	int temp[10]={-1,}; // 이렇게 하면 -1이 10개 들어있는 배열이 선언된다.
	// 마이너스로 해두는 이유는 나중에 솎아낼 때 편하기 위해서인 것 같다. 
	
	// 배열 안에 3이 몇 개 있는지 확인한다... 이 말이 코드로 어떻게 전개되어야 할까? 
	// 배열 안에 3이 몇 개 있냐... 배열의 임의의 공간의 값이 3이냐? 
	// 배열의 0번 인덱스에 저장되어 있는 값이 3과 같냐?
	// if(arr[0] == 3)
	// 배열의 공간 전부를 확인해야 하니까 0번 인덱스부터 9번 인덱스까지 해야지.
	// if(arr[0] == 3), if(arr[1] == 3), if(arr[2] == 3), if(arr[3] == 3), ...
	// 카운팅 변수를 하나 만들자...
	int count=0;
	int sign=1;
	int i; 
	int num=7; 
	for(i=0; i<10; i++){//i의 값의 범위는 0~9다. 
		if(arr[i] == num){//x의 값의 범위는 0~9다. i랑 x랑 범위가 같으니 i를 쓰자. 
			// 이 때 카운팅 하는 것이다. 카운팅은 1을 증가시키는 것이다. 
			count = count + 1; 	
			sign =0; // 카운트를 쓰지 않고 sign에게 특정 값을 줘서 할 수 있어. 
				 
		}
	}
	
	if(count != 0){
		printf("배열 안의 %d은 %d개 있습니다.", num, count);
	}else{
		printf("배열 안에 %d이 없어요.", num);
	}
	
	
	if(sign != 0){
		
		printf("배열 안에 %d이 없어요.", num);
	}else{
		printf("배열 안의 %d은 %d개 있습니다.", num, count);
	}	
	
	return 0;
}    



2023-12-06

관계 데이터 모델
  - 표 -> 관계형 데이터 모델
  - E.F.Codd가 1972년 제안한 데이터 모델.
  - 실세계 데이터를 행과 열로 구성된 표 형태로 저장.
  - 한 테이블의 필드 값을 이용하여 다른 테이블에 관련된 데이터를 찾는 식으로 검색하는 데이터 모델.
  - 데이터 간의 관계를 기본키와 이를 참조하는 외래키로 표현하는 데이터 모델.

릴레이션(표)의 구조
* 릴레이션(Relation)
  - 행(Row)과 열(Column)로 구성되는 테이블.
  - 릴레이션 스킴(Relation Scheme)과 릴레이션 인스턴스(Relation Instance)로 구성.
    -- 릴레이션 스킴: 릴레이션의 논리적 구조를 나타내며, 릴레이션 스미카라고도 함.
                          <학생>(학번, 성명, 학년, 반) --> 표의 구조를 말하는거구나! 표의 속성들을 말하는거구나!
    -- 릴레이션 인스턴스: 릴레이션의 실제 값들을 나타내며, 릴레이션 어커런스(Occurrence)라고도 함.
                               (1, 홍길동, 1, 3)
                               (2, 임꺽정, 2, 2)

* 속성(Attribute)
  - 릴레이션을 구성하는 각각의 열을 의미함. --> 컬럼도 열이야. 같은 것을 지칭하는데 용어가 다름.
  - 개체(Instance)의 특성이나 상태를 나타냄.
  - 데이터베이스를 구성하는 최소 논리 단위.
  - 테이블의 각 열을 의미함.

* 튜플(Tuple)
  - 릴레이션을 구성하는 각각의 행을 의미함.
  - 속성값들의 집합으로 구성.
  - 파일 구조의 레코드(Record)와 같은 의미.

* 관계(Relation)
  - 개체간의 상호 작용을 나타냄.

* 도메인(Domain)
  - 하나의 속성이 취할 수 있는 같은 타입의 원자(Atomic) 값들의 집합. --> 전화번호에 집전화, 폰번호 다 적으면 문제 있어. 둘을 쪼개서 속성을 두 개로 나눠라.
  - 표현되는 속성 값의 범위를 나타냄.
    <초등학생> 릴레이션의 학년 속성 도메인: 1~6  --> 7학년, 8학년은 없다. 사람의 나이는 넉넉잡이 150살 이렇게 잡아줌.

* 차수(Degree)
  - 릴레이션 스키마를 구성하는 속성의 개수

* 카디널리티(Cardinality)
  - 릴레이션에 포함되어 있는 튜플의 수

* 릴레이션의 특성
  - 튜플의 유일성: 하나의 릴레이션에는 중복되는 튜플이 존재할 수 없음.  --> 식별할 수 없음. 키(Key)라는 개념이 필요.

  - 튜플의 무순서성: 한 릴레이션에 포함된 튜플 사이에는 순서가 의미 없음.

  - 속성의 무순서성: 속성들 간에는 순서가 의미 없음.

  - 속성값의 원자성: 모든 속성값은 논리적으로 더 이상 분해할 수 없는 값인 원자값이어야 함.

  - 속성명의 유일성: 한 릴레이션을 구성하는 속성명은 중복되어서는 안 됨.(속성값은 중복될 수 있음)

* 키(Key)
  - 튜플을 유일하게 식별할 수 있는 속성 집합.
  - 튜플을 검색하거나 정렬할 때 튜플들을 서로 구별할 수 있는 기준이 되는 속성.
  - 키의 특성
    -- 유일성: 하나의 키값으로 하나의 튜플만을 식별할 수 있음.
    -- 최소성: 키를 구성하는 속성 하나만 제외시켜도 유일성이 깨지도록 꼭 필요한 최소의 속성으로만 구성.

* 키의 종류
  - 후보키(Candidate Key)
    -- 릴레이션에 있는 모든 튜플들을 유일하게 식별할 수 있는 하나 또는 몇 개의 어트리뷰트 집합

  - 기본키(Primary Key)
    -- 후보키 중에서 특별히 선정된 키로 중복될 수 없음.
    -- 널(Null) 값을 가질 수 없음.
    -- 외래키에 의해 참조됨.
    -- 유일성, 최소성 모두 만족함.

  - 대체키(Alternate Key)
    -- 후보키가 둘 이상 되는 경우에 그 중에서 어느 하나를 선정하여 기본키라 지정하면, 나머지 후보들은 대체키가 됨.

  - 슈퍼키(Super Key)
    -- 튜플을 유일하게 구별하기 위해 한 개 이상의 속성들의 집합으로 이루어진 키.  --> 회원제로 이뤄지는 마트 영수증의 프라이머리키를 만들 때 '회원번호+주문번호+구매품목' 이런 식으로 더해서 만드는 것.
    -- 한 릴레이션에서 유일성은 만족시키지만 최소성은 만족시키지 못 함.

  - 외래키(Foreign Key)
    -- 어떤 릴레이션 R1의 기본키의 값들과 일치함을 요구하는 다른 릴레이션 R2의 한 속성을 의미.
    -- 관계 데이터 모델에서 한 릴레이션의 외래키는 참조 릴레이션의 기본키와 대응되어 릴레이션 간의 참조 관계를 표현하는 데 사용되는 중요한 도구.
    -- 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음.
    -- 참조무결성 제약 조건과 밀접한 관계를 가짐.

* 무결성(Integrity)
  - 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미.
  - 데이터베이스를 정확하고 유효하게 유지(데이터의 정확성)
  - 제약조건을 통해 무결성 유지.  --> CHECK로 제약조건을 줄 수 있어.
  - 무결성 제약(Integrity Constraint)은 데이터베이스 내에 저장되는 데이터 값들이 항상 일관성을 갖고 데이터의 유효성, 정확성, 안정성을 유지할 수 있도록 하는 제약조건을 두는 데이터베이스의 특성.
  - 무결성 제약에는 개체 무결성 제약과 참조 무결성 제약, 도메인 무결성 제약 등이 있음.

* 개체 무결성 제약 조건
  - 한 릴레이션의 기본키를 구성하는 어떠한 속성 값도 널(NULL) 값이나 중복 값을 가질 수 없음.

* 도메인 무결성 제약 조건
  - 조어진 속성 값이 그 속성이 정의된 도메인에 속한 값이어야 함.

* 참조 무결성 제약 조건
  - 릴레이션 R1에 저장된 튜플이 릴레이션 R2에 있는 튜플을 참조하려면 참조되는 튜플이 반드시 R2에 존재해야 한다는 데이터 무결성 규칙(R2의 기본키를 R1의 외래키로 참조함)
  - 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없음.
  - 외래키의 속성들은 참조하려는 테이블의 기본키와 도메인이 동일해야 함.
  - 외래키 값은 참조하려는 테이블의 기본키 값으로 존재해야 함.


CREATE TABLE userTBL(
	userID CHAR(8) PRIMARY KEY,
	NAME VARCHAR(10),
	birthYear INT CHECK (birthYear>=1900 AND birthYear<=2023),
	email VARCHAR(50) UNIQUE,
	addr CHAR(2) NOT NULL DEFAULT '서울',
	CONSTRAINT ck_name CHECK(NAME IS NOT NULL) -- 위의 이름에 제약조건을 추가해줌.
);

CREATE TABLE buyTBL(
num INT AUTO_INCREMENT PRIMARY KEY,
userID CHAR(8) NOT NULL,
prodName CHAR(6)
-- FOREIGN KEY (userID) REFERENCES userTBL(userID)
);

DROP TABLE buyTBL;
DROP TABLE userTBL;

ALTER TABLE buyTBL
ADD CONSTRAINT FK_userTBL_buyTBL
FOREIGN KEY (userID)  REFERENCES userTBL (userID);

-- 스토어드 함수(Stored Function)
-- 1. 스토어드 함수의 파라미터(매개변수)는 모두 입력 파라미터로 사용한다.
-- 2. 스토어드 함수는 RETURNS문으로 반환할 값의 데이터 형식을 지정한다. -- 지정할 때는 리턴이 아니라 리턴스
-- 3. 본문 안에서는 RETURN문으로 하나의 값을 반환해야 한다.
-- 4. 스토어드 함수를 호출할 때는 select 문장으로 호출한다.

USE test00;
DROP FUNCTION if EXISTS userFunc;

DELIMITER $$ 
CREATE FUNCTION userFunc(VALUE1 INT, VALUE2 INT)
	RETURNS INT 
BEGIN -- 여기가 시작하는 곳입니다.
	RETURN VALUE1 + VALUE2;
END $$ -- 여기가 끝나는 곳입니다.

DELIMITER ;

SELECT userFunc(10, 20) AS 합계;

-- 출생 연도를 입력하면 나이가 출력되는 함수 만들기
DROP FUNCTION if EXISTS getAgeFuncMe;

DELIMITER $$
CREATE FUNCTION getAgeFuncMe(birthYear INT)
	RETURNS INT
BEGIN
	RETURN 2023 - birthYear;
END $$
DELIMITER ;

SELECT getAgeFuncMe(2003) AS 나이;



DROP FUNCTION if EXISTS getAgeFunc;

DELIMITER $$
CREATE FUNCTION getAgeFunc(bYear INT)
	RETURNS INT 
BEGIN
	DECLARE age INT;
	SET age = YEAR(CURDATE()) - bYear;
	RETURN age;
END $$
DELIMITER ;

SELECT getAgeFunc(2003);

USE test00;
-- 스토어드 프로시저
-- 쿼리문의 집합... 일괄처리 용
DROP FUNCTION if EXISTS userProc;

-- 매개변수가 없는 프로시저
DELIMITER $$
CREATE PROCEDURE userProc()

BEGIN
	SELECT * FROM student; -- 이걸 원한단 말이야. 그러면 밑에 CALL userProc(); 해주면 나온다.
END $$
DELIMITER ;

CALL userProc();

-- 함수는 select로 부르고 프로시저는 call로 부른다.

-- 매개변수가 있는 프로시저 
DROP PROCEDURE if EXISTS stuProc1;

DELIMITER $$
CREATE PROCEDURE stuProc1(IN stuName VARCHAR(20))
BEGIN
	SELECT * FROM student WHERE stu_name = stuName;
END $$
DELIMITER ;

CALL stuProc1('유가인');

-- 매개변수가 하나 더 있음

DROP PROCEDURE if EXISTS stuProc2;
DELIMITER $$
CREATE PROCEDURE stuProc2(
	IN height INT, 
	IN weight INT
	)
BEGIN
	SELECT * FROM student
	WHERE stu_height > height AND stu_weight < weight;
END $$
DELIMITER ;

CALL stuProc2(170, 100);


-- 특이한 것

CREATE TABLE if NOT EXISTS testTBL(
	id INT AUTO_INCREMENT PRIMARY KEY,
	txt CHAR(10)
); -- 테스트용 테이블

DROP PROCEDURE if EXISTS stuProc3;
DELIMITER %%
CREATE PROCEDURE stuProc3(
	IN txtValue CHAR(10), -- 입력매개변수
	OUT outValue INT -- 출력매개변수
)
BEGIN
	INSERT INTO testTBL VALUES(NULL, txtValue);
	SELECT MAX(id) INTO outValue FROM testTBL;
END %%
DELIMITER ;

CALL stuProc3('테스트값', @myValue); -- 이것을 세 번 정도 실행하고 아래의 코드를 실행하면 입력된 값이 3이 나옴.
SELECT CONCAT('현재 입력된 id값 ==> ', @myValue);

-- if ~ else
DROP PROCEDURE if EXISTS ifelseProc;
DELIMITER $$
CREATE PROCEDURE ifelseProc(
	IN userName VARCHAR(20)
)
BEGIN
	DECLARE height INT; -- 변수 선언
	SELECT stu_height INTO height FROM student -- stu_height의 값을 height에 넣겠다 이 말이야.
	WHERE stu_name = userName;
	
	if(height >= 170) then 
		SELECT '키가 크군요.';
	ELSE
		SELECT '키가 크진 않군요.';
	END if;
END $$
DELIMITER ;

CALL ifelseProc('옥성우');
CALL ifelseProc('심수정');



*** 정보처리기사 시험 준비 요령 (준비물: 5회차 분 기출 문제)
1. 기출문제를 그냥 읽는다. 모르는 것이 있으면 밑줄을 긋는다. 3회차 정도 읽어 본다.  -> 유형 숙지, 하루면 됨.
2. 문제를 읽고 답을 체크한다. -> 풀지 말고 문제를 읽으면서 체크만 한다. 
3. 기본서에 답을 달면서 슬슬 읽어 본다.
4. 그래도 잘 모르겠으면 동영상 강의를 본다.
5. 4회차 문제를 풀어본다.
6. 5회차 문제를 풀어본다.
7. 1, 2, 3, 4, 5회차 문제를 풀어본다.




#include <stdio.h>

int k = 10000; //전역변수선언

void swap(int *x, int *y){ // 변수를 선언하는 시점에 사용하면 int x는 주소값을 저장할 거예요. 

	int temp;
	temp = *x; // 변수를 사용하는  시점에 *을 쓰면 그 주소값이 담고 있는 값을 쓸겁니다.  
	*x=*y;
	*y=temp;
	printf("x: %d, y: %d\n", *x, *y);// 200, 10
	
	//리턴값에 각각을 넣어서 아래에서 받아온다?!
	return 0; 
}

int main(){
	int n1 = 10;
	int n2 = 200;
	
	swap(&n1, &n2); 

	printf("n1: %d, n2: %d\n", n1, n2); // n1는 200, n2는 10 이렇게 되게 해라. 그런데 이상태로는 이렇게 안 됨. 포인터를 이용해서 주소값을 받아와서 해야해.
	// 값을 주면서 하는 것은 값에 의한 전달
	// 주소를 주면서 하는 것은 주소에 의한 전달(?) - 선생님 나이탓에 용어를 기억해 내지 못하심. 
	return 0;
}



#include <stdio.h>

int *f(){
	int a[3] ={1, 2, 3}; // 이건잘못된함수야. 그래도 그냥 예시를 들기 위해서 한거다. 배열이 전역변수가 아니기 때문에 문제가 생김. 
	return a; // []는 방번호를 쓸 때만 필요하고 배열 자체를 사용하려면 a만 쓰면 됨. 배열의 이름 자체가 주소니까 *을 안 써도 됨. 
	// 리턴으로는 하나의 값만 보낼 수 있어. 이때 보내는 것은 주소다. 
	// 여러개를 보내고 싶으면 배열을 보내거나 그러면 된다. 
	// 배열의 이름은 주소다. 배열의 이름 = 주소
} 
int main(){

	return 0;
}

// 참조변수는 주소를 저장하는 변수다.  



#include <stdio.h>

// 26개의 숫자(정수)를 저장할 수 있는 배열이 있음.
// 그 배열의 이름은 array.
// 반목문1) array[0]=65;.... 66, 67,... 순서로 한다.
// 반복문2) 화면에 출력
// 반목문3) 그 출력한 애를 %d가 아니라 %c로 해서 출력 
int upper=65;
int lower=32;
int main(){
	int array[26];
	int i;
	for(i=0; i<26; i++){
		array[i]=i+upper;
//		printf("%d\n", array[i]);
	} 
	
	int j=0;
	for(i=0; i<26; i++){
		array[i]=j+upper;
		j++;
		printf("%d\n", array[i]);
	} 
	char k;
	for(k=0; k<26; k++){
		array[k]=k+upper+lower;
		printf("%c\n", array[k]);//ABCD나옴
		 
	} 	
	return 0;
}



#include <stdio.h>

// 26개의 숫자(정수)를 저장할 수 있는 배열이 있음.
// 그 배열의 이름은 array.
// 반목문1) array[0]=65;.... 66, 67,... 순서로 한다.
// 반복문2) 화면에 출력
// 반목문3) 그 출력한 애를 %d가 아니라 %c로 해서 출력 
int upper=65;
int lower=97;
int main(){
	int array[26];
	int i;
	for(i=0; i<26; i++){
		array[i]=i+upper;
//		printf("%d\n", array[i]);
	} 
	
	int j=0;
	for(i=0; i<26; i++){
		array[i]=j+upper;
		j++;
		printf("%d\n", array[i]);
		printf("%c\n", array[i]);
	} 
//	char k;// 이런 것 하지 않아도 그냥 되는구나... 
	for(i=0; i<26; i++){
		array[i]=i+lower;
		printf("%c\n", array[i]);//ABCD나옴
		 
	} 	
	return 0;
}

// 이걸 주소값 받아와서 하는 방식으로 하려고 하다니 대박이다. 나도 해봐야지. 



#include <stdio.h>
// 26개의 숫자(정수)를 저장할 수 있는 배열이 있음.
// 그 배열의 이름은 array.
// 반목문1) array[0]=65;.... 66, 67,... 순서로 한다.
// 반복문2) 화면에 출력
// 반목문3) 그 출력한 애를 %d가 아니라 %c로 해서 출력 
int main(){
	int arr[26];
	
	int i;
	for(i=0; i<26; i++){
		arr[i] = 65 +i;
		printf("%d = ", arr[i]);
		printf("%c = ", arr[i]);
		printf("%c\n", arr[i]+32);
	}
	
}



#include <stdio.h>

// 캐릭터는 숫자로 바로 치환이 된다. 
int main(){
	char array[26];
	int i;
	int idx=0;
	for(i=0; i<26; i++){
		array[i] = 'A' + i;
	}
	
	int j;
	for(j=0; j<26; j++){
		printf("%c", array[j]);
	}
	
	return 0;
}


#include <stdio.h>
#include <string.h>

// 구조체: 배열의 개념에서 확장된 개념. 다른 유형의 데이터를 담을 수 있다. 
// 구조체는 사용자가 직접 만들어 쓰는 자료형이다.(사용자 정의 자료형)
// 여기서 한 단계 올라간 것이 클래스. 클래스 역시 사용자 정의 자료형이다.  
struct Student{
	int sno;
	char name[20];
	int score;
};

int main(){

	struct Student s01; // Student는 자료형, s01은 구조체의 이름.
	s01.sno = 1; // 그냥 선언된 것이 아니라 구조체 안에 선언되어 있으니까 구조체를 거쳐서만 접근할 수 있다. s01.sno 이렇게 해서 가야해.
	strcpy(s01.name, "홍길동"); // C언어의 특징인데 문자열을 넣을 때는 복사를 해서 넣어야 한다. 
	s01.score = 100;
	
	printf("번호: %d\n", s01.sno);	
	printf("이름: %s\n", s01.name); // 문자열을 출력할 때는 %s 
	printf("점수: %d\n", s01.score);
	return 0;
}


#include <stdio.h>
#include <string.h>

// 구조체: 배열의 개념에서 확장된 개념. 다른 유형의 데이터를 담을 수 있다. 
// 구조체는 사용자가 직접 만들어 쓰는 자료형이다.(사용자 정의 자료형) 
// 여기서 한 단계 올라간 것이 클래스. 클래스 역시 사용자 정의 자료형이다.  

// 자바 맛보기 
class A{
	int n;
	String s;
	
	int f(){
		return 3;
	}
};

int main(){

	A a= new A(); // 자바에서 객체를 만드는 법 
	a.n = 10;
	int x = a.f();
	return 0;
}





#include <stdio.h>
#include <string.h>
// 세 명의 학생이 있다.
// 학생은 번호, 이름, 국어점수, 영어점수로 이뤄짐(구조체)
// 세 명의 학생을 선언하고 위의 데이터를 집어넣어라.
// 개별 학생의 총점을 구하고, 세 학생의 총점을 구해라.  
// 학생들의 점수를 다 배열에다 저장하고. 그 배열의 총 합을 구할 수 있다. 

struct Student{
	int sno;
	char name[20];
	int korScore;
	int engScore;
};

int main(){
	struct Student s1;
	struct Student s2;
	struct Student s3;
	
	s1.sno = 1;
	strcpy(s1.name, "홍길동");
	s1.korScore = 80;
	s1.engScore = 90;

		
	s2.sno = 2;
	strcpy(s2.name, "고길동");
	s2.korScore = 70;
	s2.engScore = 100;
	
		
	s3.sno = 3;
	strcpy(s3.name, "박길동");
	s3.korScore = 99;
	s3.engScore = 97;
	
//	// 위의 것을 아래와 같이 바꿀 수 있음. 
//	struct Student students[3];
//	struct Student s1={1, "홍길동", 10, 20};
//	struct Student s2={2, "고길동", 20, 30};
//	struct Student s3={3, "박길동", 30, 40};
//	
//	students[0] = s1;
//	students[1] = s2;
//	students[2] = s3;


	int stuTotal01 = s1.korScore + s1.engScore; 
	printf("%s의 총점 %d\n", s1.name, stuTotal01);
	
	int stuTotal02 = s2.korScore + s2.engScore; 
	printf("%s의 총점%d\n", s2.name, stuTotal02);
	
	int stuTotal03 = s3.korScore + s3.engScore; 
	printf("%s의 총점%d\n", s3.name, stuTotal03);		
	
	int studentsTotal = stuTotal01 + stuTotal02 + stuTotal03;
	printf("모든 학생의 총점%d\n", studentsTotal);	
	
	int arr[3];
	
	arr[0] = stuTotal01;
	arr[1] = stuTotal02;
	arr[2] = stuTotal03;		
	
	int i;
	int j=0;
	for(i=0; i<3; i++){
//		printf("배열출력%d\n", arr[i]);
		j= j+arr[i];
	}
	printf("모든 학생의 총점%d\n", j);


	return 0;
}


*** 물리적으로 안 되는 것을 하라고 하면 어떻게 해야 하나?  
  --> 열심히 하는 시늉만 해라.
  --> 어차피 분명히 실패할 것이 확실하다고 판단된다면 그 업무의 대안을 만들어 놓아라.
  --> 당신들(관리자)의 말은 맞는데 환경이 이러이러해서 불가피한 상황이었습니다. 라고 해라.


2023-12-07

-- Trigger(트리거)
CREATE TABLE testtbl(
	id INT,
	txt VARCHAR(10)
);

INSERT INTO testtbl VALUES
(1, 'aaaa'),
(2, 'bbbb'),
(3, 'cccc');

SELECT * FROM testtbl;

DELIMITER // -- ';' 역할을 '//' 가 대신하겠다. 요 안에서 ;는 쿼리의 종료가 아니다. 이건 정해진 것이 아니라 안 쓰는 것을 쓰면 된다.
CREATE TRIGGER testTrg
	AFTER DELETE -- 딜리트가 발생한 후에, before를 쓰면 전에도 가능
	ON testtbl -- testtbl이라는 테이블에서 딜리트가 발생하면
	FOR EACH ROW -- 각 행마다 부착을 시켜라. 
	
BEGIN
	SET @msg = '삭제가 되었어요.'; -- 트리거 실행 시 작동되는 코드
END //
DELIMITER ;

SET @msg = ''; 
INSERT INTO testtbl VALUES(4, 'dddd');
SELECT @msg;

UPDATE testtbl SET txt = 'xxxx' WHERE id =4;
DELETE FROM testtbl WHERE id=4;
SELECT * FROM testtbl;
SELECT @msg;

-- 딜리트할 때만 메시지가 생겼는데 그게 트리거의 비긴 엔드에 써 놓은 것과 일치해.
-- testbl에서 delete가 발생하면 trigger가 발생함.
-- DBMS에 뭔가 발생했을 때 뭔가 후속으로 발생해야 하는 이벤트가 있을 때 혹은 전에 발생해야 하는 이벤트가 있을 때 사용함.
-- 비포에는 주로 유효성 검사 등을 하고 
-- 에프터에는 업데이트 할 때 어떤 흔적을 남기거나 후속적으로 저장을 한다는 등의 작업을 한다.
-- 회원이 탈퇴를 하면 그 사람들을 다 삭제하는 것이 아니라 탈퇴한 사람들의 정보를 저장해서 탈퇴한 사람들에 대한 통계.분석 등을 할 수 있다.

-- 회원 테이블에 update나 delete를 시도하면
-- 수정/삭제된 데이터를 별도의 테이블에 보관하고 변경된 일자와 변경한 사람을 기록하자.

CREATE TABLE userTBL(
	userID CHAR(8)PRIMARY KEY,
	NAME VARCHAR(20) NOT NULL,
	birthYear INT NOT NULL,
	addr CHAR(2) NOT NULL,
	mobile1 CHAR(3),
	mobile2 CHAR(8),
	height SMALLINT,
	mDate DATE 
);

INSERT INTO userTBL VALUES 
('HGD', '홍길동', 1980, '서울', '010', '11112222', 173, '2023-01-23');
INSERT INTO userTBL VALUES 
('KGD', '고길동', 1990, '김포', '010', '22223333', 190, '2023-01-30');
SELECT * FROM userTBL;
DROP TABLE backupUserTBL;
CREATE TABLE backupUserTBL(
	userID CHAR(8), -- userID가 PRIMARY KEY면 업데이트를 두 번 할 때 오류가 난다.
	NAME VARCHAR(20) NOT NULL,
	birthYear INT NOT NULL,
	addr CHAR(2) NOT NULL,
	mobile1 CHAR(3),
	mobile2 CHAR(8),
	height SMALLINT, -- SMALLINT는 2바이트 그런데 세 자리 숫자?
	mDate DATE,
	modType CHAR(2), -- 변경된 타입(수정 또는 삭제)
	modDate DATE, -- 변경된 날짜
	modUser VARCHAR(256) -- 변경한 사용자
);

DROP TRIGGER if exists backupUserTBL_UpdateTrg;

DELIMITER //
CREATE TRIGGER backupUserTBL_UpdateTrg
	AFTER UPDATE 
	ON userTBL
	FOR EACH ROW 
BEGIN
	INSERT INTO backupUserTBL VALUES 
	(OLD.userID, OLD.name, OLD.birthYear, OLD.addr, OLD.mobile1, OLD.mobile2, OLD.height, OLD.mDate, '수정', CURDATE(), CURRENT_USER());
	-- 마지막 세 개는 유저테이블에는 없고 백업유저테이블에만 있는 것이므로 이것을 변경해서 넣어줌.
END //
DELIMITER ;

UPDATE userTBL SET height = 200 WHERE  userID = 'HGD';
SELECT * FROM userTBL;
SELECT * FROM backupUserTBL;
UPDATE userTBL SET addr = '부산' WHERE  userID = 'HGD';

DROP TRIGGER if EXISTS backupUserTBL_DeleteTrg;

DELIMITER //
CREATE TRIGGER backupUserTBL_DeleteTrg
AFTER DELETE
ON userTBL
FOR EACH ROW 
BEGIN
	INSERT INTO backupUserTBL VALUES 
	(OLD.userID, OLD.name, OLD.birthYear, OLD.addr, OLD.mobile1, OLD.mobile2, OLD.height, OLD.mDate, '삭제', CURDATE(), CURRENT_USER());
END //
DELIMITER ;



TRUNCATE TABLE usertbl; -- 테이블의 구조는 남고 데이터만 사라짐. 이렇게 지우면 backupUserTBL에는 변화가 없음. DDL이다.


SELECT * FROM userTBL;
SELECT * FROM backupUserTBL;

DELETE FROM userTBL WHERE userID = 'KGD';


-- 데이터가 테이블에 입력될 때 출생 연도를 검삭해서 데이터에 문제가 있는지 확인
-- 값을 변경해서 입력시키는 before insert 트리거를 작성해 보기.
-- 출생 연도는 1900년 이후여야 한다. 
-- 1900보다 작으면 0으로 설정한다.
-- 출생 연도가 현재 연도보다 크면 현재 연도로 변경한다. 
DROP TRIGGER if EXISTS userTBL_BeforeInsertTrg;

DELIMITER //
CREATE TRIGGER userTBL_BeforeInsertTrg
BEFORE INSERT
ON userTBL
FOR EACH ROW 
BEGIN
	if NEW.birthYear < 1900 then -- OLD, NEW는 테이블을 말한다. 임시테이블
		SET NEW.birthYear = 0;
	ELSEIF NEW.birthYear >= YEAR(CURDATE())	then
		SET NEW.birthYear = YEAR(CURDATE());
	END if;	
END //
DELIMITER ;

INSERT INTO userTBL VALUES 
('CGD', '최길동', 1887, '김해', '010', '33334444', 160, '2023-01-27'),
('OGD', '오길동', 2000, '남해', '010', '44445555', 300, '2023-01-27');

UPDATE userTBL SET birthYear = 2000 WHERE NAME = '최길동';

SELECT * FROM userTBL;
SELECT * FROM backupUserTBL;

INSERT INTO userTBL VALUES 
('KGD', '강길동', 2024, '강원', '010', '55556666', 10, '2021-01-27'); -- 출생 연도를 2024로 넣으니 2023으로 입력되었다.

-- 나중에 프로젝트 진행할 때 트리거정도는 써보면 좋겠다.










-- Transaction(트렌젝션): 논리적으로 구성된 일의 최소 단위, 더 이상 쪼개면 일이 아니다.
-- rollback(했던 작업 취소), commit(작업 영구 저장)
-- 마리아디비는 오토커밋. 

SELECT * FROM userTBL;
SELECT * FROM backupUserTBL;
START TRANSACTION; -- 이 쿼리를 실행하고 다음 쿼리를 실행한 후 롤백을 해야 먹힌다. 스타트 트렌젝션은 롤백 할때마다 해줘야 해.
INSERT INTO userTBL VALUES ('xxx', 'xxx', 1998, '경기', '010', '67778888', 156, '2022-08-20');
SAVEPOINT a;
INSERT INTO userTBL VALUES ('zzz', 'zzz', 1998, '경기', '010', '67778888', 156, '2022-08-20');
SAVEPOINT b;

DELETE FROM userTBL WHERE userID = 'CGD';

ROLLBACK TO a; -- 세이브포인트 에이를 한 시점으로 되돌아 가서 zzz는 없고,  CGD는 있음.
ROLLBACK TO b; -- a로 이미 가서 b는 존재하지도 않는 상태가 됨.

COMMIT; -- 커밋을 한 번 하면 롤백을 할 수 없다.


-- 뷰(view): 논리적으로 존재하는 테이블! 물리적으로 존재하지 않는다. 그러나 어쨌든 테이블이다.
-- 기존에 있는 테이블로부터 데이터를 받아와서 하나의 테이블처럼 존재한다.
-- 물리적 테이블과 똑같이 데이터를 출력할 수 있지만 막 입력하고 그럴 수 없다(?)
-- 회사에서 사용하는 데이터는 공통된 데이터만 각 직급별로 볼 수 있는 데이터의 종류나 권한 등이 다르다.
-- 그 때 뷰를 쓰면 보안에 좋다.

USE rest;
SELECT * FROM usertbl;

CREATE VIEW v_userTBL
AS
(SELECT userID, NAME, birthYear FROM usertbl);

SELECT * FROM v_userTBL;



















CREATE TABLE dept(
	-- deptCode CHAR(2) PRIMARY KEY CHECK(deptCode IN('AA', 'BB', 'CC'), -- 이렇게 범위가 좁은데 식별자가 되나?
	deptCode CHAR(2) PRIMARY KEY, -- 이렇게 범위가 좁은데 식별자가 되나?
	deptName VARCHAR(10) NOT NULL,
	AREA VARCHAR(10) NOT NULL DEFAULT '부산'
);

CREATE TABLE employees(
	eno INT AUTO_INCREMENT PRIMARY KEY,
	ename VARCHAR(20) NOT NULL,
	deptCode CHAR(2) NOT NULL,
	grade CHAR(2) NOT NULL CHECK(grade IN('인턴', '사원', '대리', '과장', '부장', '이사', '사장')),
	FOREIGN KEY(deptCode) REFERENCES dept(deptCode)
);


INSERT INTO dept(deptCode, deptName, AREA) VALUES
('AA', '인사', '부산'),
('BB', '영업', '서울'),
('CC', '개발', '부산')
;

;
SELECT * FROM dept;

INSERT INTO employees(ename, deptCode, grade) VALUES
('김영철', 'AA', '사장'),
('김형철', 'AA', '이사'),
('나영철', 'AA', '부장'),
('김희철', 'AA', '과장'),
('김영희', 'AA', '대리'),
('김영호', 'AA', '사원'),
('김영호', 'AA', '사원'),
('나영철', 'BB', '부장'),
('다희철', 'BB', '과장'),
('김영희', 'BB', '대리'),
('마영호', 'BB', '사원'),
('김영호', 'BB', '사원'),
('나영철', 'CC', '부장'),
('김희철', 'CC', '과장'),
('김영희', 'CC', '대리'),
('가영호', 'CC', '사원'),
('나영호', 'CC', '사원')
;

-- 1. 직급이 '사원'인 사람의 사번과 이름을 조회하시오.
SELECT grade, ename FROM employees WHERE grade = '사원';
-- 2. 성이 '김'씨인 직원의 이름, 부서코드를 조회하시오.
SELECT ename, deptCode AS 부서명 FROM employees WHERE ename LIKE '김%';
-- 3. 부서별 직원 수를 조회하시오.
SELECT deptCode AS 부서코드, COUNT(*) FROM employees GROUP BY deptCode;
-- 4. 조회결과로 사번, 이름, 부서코드, 부서명이 나오도록 쿼리를 작성하시오.
SELECT e.eno, e.ename, e.deptCode, d.deptName FROM employees e, dept d WHERE e.deptCode = d.deptCode;
SELECT e.eno, e.ename, e.deptCode, d.deptName FROM employees e, dept d;
-- 5. 사번이 3번인 사원의 직급을 한단계 승진시키시오.
UPDATE employees SET grade ='이사' WHERE eno = 3;
SELECT * FROM employees WHERE eno = 3;
-- 6. 사번이 5번인 사원을 삭제하시오.
DELETE FROM employees WHERE eno =5;
SELECT * FROM employees;


-- 시험 연습
-- 부서 테이블 만들기
CREATE TABLE depttbl(
	deptCode CHAR(2) PRIMARY KEY,
	deptName VARCHAR(10) NOT NULL,
	AREA VARCHAR(10) NOT NULL DEFAULT '부산'
);
-- 사원 테이블 만들기
CREATE TABLE emptbl(
	eno INT AUTO_INCREMENT PRIMARY KEY,
	ename VARCHAR(20) NOT NULL,
	deptCode CHAR(2) NOT NULL, -- 외래키
	grade CHAR(2) NOT NULL CHECK(grade IN('인턴', '사원', '대리', '과장', '부장', '이사', '사장')),
	FOREIGN KEY(deptCode) REFERENCES depttbl(deptCode)
);

INSERT depttbl(deptCode, deptName, AREA) VALUES
('AA', '인사', DEFAULT),
('BB', '영업', '서울'),
('CC', '개발', DEFAULT)
;

INSERT emptbl(ename, deptCode, grade) VALUES
('김복길', 'AA', '사장'),
('강동구', 'BB', '이사'),
('최대치', 'AA', '대리'),
('오만상', 'CC', '사원'),
('구본승', 'AA', '인턴');

SELECT eno, ename FROM emptbl WHERE grade = '사원';
SELECT ename, deptCode FROM emptbl WHERE ename LIKE '김%';
SELECT deptCode, COUNT(*) AS 부서명 FROM emptbl GROUP BY deptCode;
SELECT * FROM emptbl WHERE eno = 3;
UPDATE emptbl SET grade = '과장' WHERE eno =3;
SELECT * FROM emptbl;
SELECT e.eno, e.ename, e.deptCode, d.deptName 
FROM emptbl e, depttbl d 
WHERE e.deptCode = d.deptCode;
DELETE FROM emptbl WHERE eno = 5;

CREATE VIEW v_emp_dept
AS
(SELECT e.eno, e.ename, e.deptCode, d.deptName 
FROM emptbl e, depttbl d 
WHERE e.deptCode = d.deptCode);
SELECT * FROM v_emp_dept;




CREATE DATABASE t;
USE t;

CREATE TABLE departmentTbl(
	deptNo CHAR(2) PRIMARY KEY,
	deptName VARCHAR(20) UNIQUE NOT NULL,
	profName VARCHAR(20) NOT NULL,
	tel CHAR(13) UNIQUE  NOT NULL
	
);
CREATE TABLE studentTbl(
	sno INT AUTO_INCREMENT PRIMARY KEY,
	sname VARCHAR(20) NOT NULL,
	deptNo CHAR(2) NOT NULL, 
	grade CHAR(1) CHECK(grade IN('1', '2', '3', '4')),
	phone CHAR(13) UNIQUE, 
	gender CHAR(1) CHECK(gender IN('M', 'F')),
	FOREIGN KEY(deptNo) REFERENCES departmentTbl (deptNo)
);

SELECT * FROM departmentTbl;
SELECT * FROM studenttbl;
DROP TABLE studenttbl;

INSERT INTO departmentTbl (deptNo, deptName, profName, tel)
VALUES
('AA', '경영', '박경영', '051-3333-3232'),
('BB', '컴퓨터공학', '김전산', '051-4444-4242'),
('CC', '교육공학', '천교육', '051-5555-5252')
;

INSERT INTO studentTbl (sname, deptNo, grade, phone, gender)
VALUES 
('김동수', 'AA', '1', '010-1111-1111', 'M'),
('나동민', 'BB', '2', '010-2222-2222', 'M'),
('도미솔', 'CC', '3', '010-3333-3333', 'F'),
('민건식', 'AA', '4', '010-4444-4444', 'M'),
('홍미정', 'CC', '2', '010-5555-5555', 'F')
;

SELECT sno, gender, grade FROM studenttbl WHERE deptNo = 'AA';

SELECT d.deptName, COUNT(*) FROM studenttbl s, departmenttbl d WHERE s.deptNo = d.deptNo GROUP BY d.deptName;
SELECT s.sno, s.sname, d.deptName, d.profName FROM studenttbl s, departmenttbl d WHERE s.deptNo = d.deptNo;

CREATE VIEW v_student_department
AS
(SELECT s.sno, s.sname, d.deptName, d.profName FROM studenttbl s, departmenttbl d WHERE s.deptNo = d.deptNo);

SELECT * FROM v_student_department;


SELECT s.sno, s.sname, d.deptNo FROM studenttbl s, departmenttbl d WHERE s.sname LIKE '_동%' AND d.deptNo LIKE '%A';

SELECT d.deptName, s.sno, s.sname, s.grade FROM studenttbl s, departmenttbl d WHERE d.deptName = '경영' AND s.deptNo = d.deptNo;






/////////// 주사위를 100번 돌려서 카운팅해서 화면에 뿌리기.

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/////////// 주사위를 100번 돌려서 카운팅해서 화면에 뿌리기.

//int random(){
//	srand(time(0));
//	int com;
//	com=rand() % 6+1;
//	return com;
//} 

int main(){
	srand(time(0));
	int com;	
//	srand(time(0));
//	com=rand() % 6+1;
	int i;
	
	int count = 0;
	for(i=0; i<100; i++){
		com = rand() % 6+1;
//		srand(time(0));
//		com=rand() % 6+1;
//		com = random();
//		printf("%d\n", com);
		count = count + com;
		printf("%d번째 수는 %d\n", i+1, com);
	}
	printf("주사위를 100번 던져서 나온 수를 합한 값은: %d", count);
	return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/////////// 배열 arrA의 값들을 짝수, 홀수 여부에 따라 arrB, arrC 배열에 넣어보자. 

int main(){
	int arrA[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	int arrB[5];
	int arrC[5];
	int i, j, k;
	for(i=0; i<10; i++){
		if(arrA[i] %2 == 0){//짝수 
			arrB[j] = arrA[i]; 
			printf("짝수 배열에 있는 수: %d\n", arrB[j]);
		}else{
			arrC[k] = arrA[i]; 
			printf("홀수 배열에 있는 수: %d\n", arrC[k]);
		}
	} 
	
	return 0;
}



2023-12-08


-- 제2 정규형(Second Normal Form): 기본키가 2개 이상인 경우에(하나의 기본키만으로 대상을 식별할 수 없는 경우) 기본키에 속하지 않는 모든 속성들이 기본키에 완전 함수 종속인 상태
-- 학번(기본키)/수강과목(기본키)/학년/점수 가 적혀 있는 표가 있어.
-- 수강과목을 알려면 학번과, 수강과목이 필요해.(완전 함수 종속 관계)
-- 점수를 알려면 학번, 수강과목, 점수가 필요해.(완전 함수 종속 관계)

-- 제3 정규형(Third Normal Form): 릴레이션이 제2 정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아닌 상태
-- 학번/학과/지도교수 이런 표가 있음(모든 부분에서 겹치는 것이 하나도 없음)
-- 학번을 알면 학과를 알고 지도교수를 알 수 있다. 이것이 순차적으로 이뤄지지 학번을 안다고 지도교수를 바로 알 수는 없다.
-- 학번이 학과를 학과가 지도교수를 알게 한다. 이런 것이 이행적 함수 종속 관계라고 한다.
-- 학번/학과, 학과/지도교수 이렇게 표를 나눌 수 있음.
-- 나눠진 표를 하나로 도출하고 싶으면 조인을 하면 됨.
-- 그럴거면 하나로 만들어서 쓰는 것이 좋지 않겠어? --> 역 정규화!
-- 역 정규화는 성능 향상을 위해 한다.
-- 뷰를 해도 좋아.


-- 학생은 성별, 이름, 학번으로 구성됩니다.(요구사항)

-- 명사를 구체화하고 추상화해서 숙지해라.(명사간의 관계를 알아보자.)
-- 학생은 과정을 수강신청할 수 있다. 
-- 학생 - 수강신청 - 과정
-- 명사들은 속성을 가진다. 수강신청도 속성을 가질 수 있다.(신청날짜 등...)
-- 학생이 수강신청을 하나만 할 수 있다면 학생1 수강신청1 이렇게 표시하는데 1:1 관계라고 한다.
-- 이렇게되면 과정도 하나만 들을 수 있기 때문에 1:1 관계가 된다.
-- 한 학생이 여러 번의 수강신청을 할 수 있다면 1:多 의 관계라고 하고 학생1 수강신청n 이렇게 쓴다.
-- 한 학생이 여러 번의 수강신청을 할 수 있고, 한 과목이 여러 학생을 수강생으로 받을 수 있다면 학생n, 수강신청n 이라고 쓰고 多:多 관계라고 한다.
-- 학생의 입장에서는 1:多의 관계가 되고 수강신청 입장에서는 1:多의 관계가 된다.

-- UML: 유즈케이스 다이어그램, ERD(ER다이어그램), 시퀀스 다이어그램 이런 애들
-- 포트폴리오에 NTT 다이어그램, 설계도 이런 것이 들어있으면 차별화된 지원자라는 인상을 심어줄 수 있어.
-- 유즈케이스 다이어그램, ERD(ER다이어그램), 시퀀스 다이어그램을 필수적으로 포트폴리오 문서에 넣어둬라. 그럼짱짱

-- 유즈케이스 다이어그램(쓰임새 다이어그램)
-- 다이어그램의 각 도형 속 기능을 명시한 동사의 명사형에 '-하다'를 붙여서 말이 되면 된다.
-- 기능을 명시한 것 = 함수도 그렇다.
-- 프로그램: 기능을 완수하기 위한 명령어의 집합
-- 액터와 직접 연결된 것들은 '주기능'이기 때문에 생략할 수 없다.(다른 것들은 생략 가능)
-- include는 주기능을 위해 반드시 포함되어야 하는 것.
-- extend는 꼭 하지 않아도 주기능을 수행할 수 있어.
-- 현금결제, 카드결제는 둘 중 하나를 선택해서 하면 되기 때문에 extend

-- 유즈케이스 다이어그램은 순서대로 사용하지 않아도 된다. 그냥 흐름을 보는 것이다.(기능에 초점)
-- 시간의 흐름이 중요한 다이어그램은 시퀀스 다이어그램이다. 



#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 주사위를 100번 던져서 나온 수의 각각의 횟수를 구해라. 
int main(){

	int dice[6]={0,0,0,0,0,0};
	int rd_num;
	int i;
	int j;
	srand(time(0));
	
	for(i=0; i<100; i++){
		rd_num = rand()%6 + 1;
	
//		if(rd_num == 1){
//			dice[0]++;
//		} else if(rd_num ==2){
//			dice[1]++;
//		} else if(rd_num ==3){
//			dice[2]++;
//		} else if(rd_num ==4){
//			dice[3]++;
//		} else if(rd_num ==5){
//			dice[4]++;
//		} else if(rd_num ==6){
//			dice[5]++;
//		}

	// 위의 코드를 줄이면 이렇게 된다.

		for(j=0; j<6; j++){
			if(rd_num == j+1){
				dice[j]++;
			}
		}
	}	
	
	for(i=0; i<6; i++){
		printf("%d] %d\n ", i+1, dice[i]);
	}
	return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <time.h>
// 열 개의 숫자가 있는데 짝수 5, 홀수 5
// A, B 배열을 5개짜리로 만들고 각각 홀, 짝 저장해라.  
int main(){
	
// 무드등이나 선별기를 만들 때도 이렇게 쉬운 것부터 시작해서 하는 것이다. 정말 대단하다 대단해.
	
//	// 나의 방법  
//	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
//	int A[5]; // 홀수 
//	int B[5]; // 짝수  
//	int i, a = 0, b = 0; // i는 아래에서 값을 0으로 주는데 a, b는 아래에 값이 지정되지 않기 때문에 초기화를 해주어야 한다.  
//					     // b를 초기화 하지 않았음에도 값이 제대로 출력되었던 것은 우연의 일치다. 
//	for(i=0; i<10; i++){
//		if(arr[i]%2 == 1){ // 홀수
//			A[a] = arr[i];
//			a++;
//		} else{ // 짝수 
//			B[b] = arr[i];
//			b++;
//		}		
//	}
//	printf("\n홀수 배열: ");
//	for(i=0; i<5; i++){
//		printf("A[%d]: %d, ",i, A[i]);
//	}
//
//	printf("\n짝수 배열: ");
//	for(i=0; i<5; i++){
//		printf("B[%d]: %d, ",i, B[i]);
//	}	

	
	// 친구의 방법
	int a[10] = {1,2,3,4,5,6,7,8,9,10};
	int b[5]; // 홀수 
	int c[5]; // 짝수  
	int i, j, k; // i는 아래에서 값을 0으로 주는데 a, b는 아래에 값이 지정되지 않기 때문에 초기화를 해주어야 한다.  
					     // b를 초기화 하지 않았음에도 값이 제대로 출력되었던 것은 우연의 일치다. 
					     
	for(i=0; i<10; i++){
		if(a[i]%2 != 0){
			for(k=0; k<6; k++){
				b[k]=a[i];
				printf("%d\n", a[i]);
				printf("%d\n", b[k]);
			}
		} else{
			for(j=0; j<6; j++){
				c[j]=a[i];
				printf("%d\n", a[i]);
				printf("%d\n", c[j]);
			}
		}
		for(i=0; i<10; i++){
			if(a[i]%2 != 0){
//				printf("a[%d]의 %d는 홀수라서 b[%d] = %d\n", i, a[i], k, b[k]);
			}else{
//				printf("a[%d]의 %d는 홀수라서 c[%d] = %d\n", i, a[i], j, b[j]);
			}
		}
	}
	return 0;
}







#include <stdio.h>

// 메뉴를 선택하라고 화면에 출력된다. 
// 자판기에서 메뉴를 선택한다.
// 얼마를 넣을지 화면에 출력한다.
// 돈을 제대로 넣으면 물건이 나온다.
// 돈을 덜 넣으면 얼마를 더 넣으라고 화면에 출력된다.
// 돈을 더 넣으면 거스름돈 얼마 라고 출력된다. 
int main(){
	 
	int menu=0;
	printf("메뉴에 해당하는 숫자를 선택하세요. 1) 일반커피, 2) 밀크커피, 3) 설탕커피, 4) 블랙커피, 5) 율무차 ");
	scanf("%d", &menu);
	int insertMoney=0; 
	int moreMoney=0;
	
	// 일반커피  
	if(menu == 1){
		printf("일반커피는 300원입니다.\n300을 입력해 주세요.");
		scanf("%d", &insertMoney);
		if(insertMoney == 300){
			printf("맛있게 드세요.");
		} else if(insertMoney < 300){
			printf("%d원을 더 입력해 주세요.", 300-insertMoney);
			scanf("%d", &moreMoney);
			if(moreMoney == 300-insertMoney){
				printf("일반커피가 나왔습니다.");
			}
		} else if(insertMoney > 300){
			printf("일반커피가 나왔습니다.\n거스름돈은 %d원입니다. 거스름돈을 챙겨주세요.", insertMoney-300);
		}
		
	// 밀크커피 
	} else if(menu == 2){
		printf("밀크커피는 400원입니다.\n400을 입력해 주세요.");
		scanf("%d", &insertMoney);
		if(insertMoney == 400){
			printf("맛있게 드세요.");
		} else if(insertMoney < 400){
			printf("%d원을 더 입력해 주세요.", 400-insertMoney);
			scanf("%d", &moreMoney);
			if(moreMoney == 400-insertMoney){
				printf("밀크커피가 나왔습니다.");
			}
		} else if(insertMoney > 400){
			printf("밀크커피가 나왔습니다.\n거스름돈은 %d원입니다. 거스름돈을 챙겨주세요.", insertMoney-400);
		}
		
	// 설탕커피  
	} else if(menu == 3){
		printf("설탕커피는 500원입니다.\n500을 입력해 주세요.");
		scanf("%d", &insertMoney);
		if(insertMoney == 500){
			printf("맛있게 드세요.");
		} else if(insertMoney < 500){
			printf("%d원을 더 입력해 주세요.", 500-insertMoney);
			scanf("%d", &moreMoney);
			if(moreMoney == 500-insertMoney){
				printf("설탕커피가 나왔습니다.");
			}
		} else if(insertMoney > 500){
			printf("설탕커피가 나왔습니다.\n거스름돈은 %d원입니다. 거스름돈을 챙겨주세요.", insertMoney-500);
		}
		
	// 블랙커피 	
	} else if(menu == 4){
		printf("블랙커피는 1000원입니다.\n1000을 입력해 주세요.");
		scanf("%d", &insertMoney);
		if(insertMoney == 1000){
			printf("맛있게 드세요.");
		} else if(insertMoney < 1000){
			printf("%d원을 더 입력해 주세요.", 1000-insertMoney);
			scanf("%d", &moreMoney);
			if(moreMoney == 1000-insertMoney){
				printf("블랙커피가 나왔습니다.");
			}
		} else if(insertMoney > 1000){
			printf("블랙커피가 나왔습니다.\n거스름돈은 %d원입니다. 거스름돈을 챙겨주세요.", insertMoney-1000);
		}
		
	// 율무차 	
	} else if(menu == 5){
		printf("율무차는 1500원입니다.\n1500을 입력해 주세요.");
		scanf("%d", &insertMoney);
		if(insertMoney == 1500){
			printf("맛있게 드세요.");
		} else if(insertMoney < 1500){
			printf("%d원을 더 입력해 주세요.", 1500-insertMoney);
			scanf("%d", &moreMoney);
			if(moreMoney == 1500-insertMoney){
				printf("율무차가 나왔습니다.");
			}
		} else if(insertMoney > 1500){
			printf("율무차가 나왔습니다.\n거스름돈은 %d원입니다. 거스름돈을 챙겨주세요.", insertMoney-1500);
		}
	} else{
		printf("메뉴를 정확히 선택해 주세요.\n시스템을 다시 시작해 주세요."); // 허접하군 
	} 
	
//	else{
//		printf("메뉴를 정확히 선택해 주세요.");
////		scanf("%d", &menu);
//      	continue;
//	} // 컨티뉴는 반복문 탈출인데 그냥 써봄. 키키키
	return 0;
} 




//////////////// 최주호 선생님 첫 수업
2023-12-11

앱을 만들려면 백엔드와 프론트가 모두 필요하다.
Flutter로 앱을 만들 것이다.

오늘은 세팅의 날

1. java
2. git 
3. 인텔리J
5. notion
7. Lightshot 
8. 7 zip
9. choco

파워쉘에서 붙여넣기 할 때는 shift + insert가 좋아.
개발자는 CLI로 명령을 내려. 보통 사람들은 GUI로 한다. 클릭해서

초코를 쓰면 뭐가 좋냐?
홈피에서 커뮤니티로 들어가면 원하는 프로그램의 설치 파일이 다 나와 있다.
PowerShell 창에서 choco install 프로그램명 적으면 설치됨 ex) choco install git
설치가 잘 되었나 확인하려면 git --version

Lightshot 
fn + f12 누르고 영역 지정한 후 ctrl + s 누르면 lightshot 폴더에 저장됨.(PowerShell창을 캡쳐하고 싶으면 다른 영역을 클릭하고 캡쳐해야해)

notion(혼자 보게 되니까 피드백이 부족) 
## 눌러서 글씨 크기? 설정. ### 누르면 더 작은 글씨(h2, h3 요런 느낌)
``` 눌러서 언어 설정해서 PowerShell 등 적고 화면에 보여줄 수 있어(?)
/콜아웃 하면 팁 적을 수 있어.
노션 사용법 유튜브 보고 공부하기

inblog.ai(공개되기 때문에 피드백을 받을 수 있다.)
내 주소(?) hyeonjeong-jang-0302

bin 폴더! binary의 약자: 실행파일이 모여 있다고 생각하면 된다.

시스템변수는 모든 아이디에서 사용하는 변수

C:\Users\G>echo %JAVA_HOME% 이걸 설정한 이유 --> 시스템의 모든 사용자가 사용할 수 있게.
초코로 설치하면 모든 것이 다 자동으로 된다.

환경변수, path는 이해해야해.


2진수
ㅁ: 도체, 부도체
ㅁ: 반도체(트리거)

0, 1

ㅁㅁㅁ 
3비트를 가지고는 8가지 경우의 수만 있으니까 약속을 해야지.
동등한 관계에서 하는 약속을 프로토콜이라고 해.

8비트 통신 -> 256가지 경우의 수 -> 문자 1개 표현(A 한 개)
8비트로 문자 하나를 표현할 수 있기 때문에 8비트를 1바이트라고 한다.(물리적인 단위가 아니라 논리적인 단위이다.)
8비트 통신을 여러번 하면 문장이 된다.

아스키코드표는 전 세계 사람들이 공유하기 때문에 암호로 쓰기엔 부적합.

인코딩(사람이 한 말을 컴퓨터 언어로 바꿔주는 것이 인코딩! 아스키코드로 할거냐? UTF-8로 할거냐? 그런 것을 정해서 보내줘야 한다.)
코딩하는 사람은 명령을 내리면서 아스키 코드로 할지 뭘로 할지만 정해서 JVM에게 보내면 돼.
디코딩(컴퓨터가 해준 말을 특정 언어로 바꿔주는 것)

폰노이만구조 - CPU(연산), RAM(저장, 휘발성) 요 두 가지만 있음.
통신을 하면 RAM에 문자가 하나씩 들어간다.

갈매기털
털 -> 1000GByte -> 1TByte
기 -> 1000MByte -> 1GByte -> 10억Byte
매 -> 1000KByte -> 1MByte -> 100만Byte
갈 -> 1000Byte -> 1KByte

기가는 10억이다. 메가는 100만이다.
16GByte -> 160억Byte
내 컴퓨터에 바이트가 160억개 있다.


1(0) 
2(1) 
4(2) 
8(3) 
16(4) 
32(5) 
64(6) 
128(7) 
256(8) 
512(9) 
1014(10)

캐시 - 더 가까운 곳에 있는 것은 다 캐시라고 한다.
메모리 입장에서는 레지스터가 캐시, 하드디스크 입장에서는 메모리(RAM)이 캐시.

IO: 램과 씨피유가 데이터를 교환하는 것을 IO라고 한다. Input/Output. IO를 줄이는 것이 코딩 잘 짜는 것보다 중요.


public class HelloWorld {
    // src는 source라는 뜻이야.
    // 클래스의 첫 글자는 무조건 대문자.
    public static void main(String[] args) {
        System.out.println("HelloWorld!"); // 자동완성 될 수 있는 조각들을 스니펫이라고 한다.
        // D:\workspace\java_lec\demo\out\production\demo 에 있는 클래스 파일을 지워도 수정하고 새로 저장하면 새로 생겨.
        // .java파일을 작성하면 .class파일이 생성된다 -> 컴파일 된다.
        // shift + f10 -> 실행
        // 마우스로 클릭을 하면 CLI로 OS(윈도우, 맥, 리눅스)에 명령을 내린다. 그러면 2진수로 HW(하드웨어)에게 명령을 내린다.
        // OS의 언어는 shell이라고 한다.
        // 언어 -> OS(윈도우, 맥, 리눅스) -> HW 순서로 명령을 내린다.
        // 자바는 언어 -> JVM(자바가상머신) -> OS(윈도우, 맥, 리눅스) -> HW 순서로 명령을 내린다.
        // .java는 인간이, .class는 JVM이 이해하는 것이다.
        // JVM이 .class를 받아서 윈도우, 맥, 리눅스로 알아서 바꿔서 뿌려준다.
        // 자바로 코드를 짜면 한방에 끝난다!!

        // 컴파일: 전체를 미리 받아서 통역을 싹 끝내 놓음(통째로번역), 실행시간이 빠름.
        // 인터프리터: 동시통역, 실행시간이 좀 느림. 파이썬 같은 것.
        // 자바는 컴파일, 인터프리터를 둘 다 해서 하이브리드 언어라고 한다.

        // javac는 .java를 .class로 바꿔주는 것이고
        // java는 .class를 JVM에게 명령하는 것이다.

    }
}


public class HelloWorld {
    public static void main(String[] args) {
        int num = -2100000000;// int는 4바이트니까 2의 32승 -21억 ~ + 21억 정도의 수를 저장 가능
        // 0 하나만 더 붙여도 오류남.
        // 1바이트가 한 칸이니까 숫자 하나를 네 칸에 나눠서 저장하는 것이야.
        System.out.println(num);
    }
}


****** 노션 사용법

## 눌러서 글씨 크기? 설정. ### 누르면 더 작은 글씨(h2, h3 요런 느낌)
``` 눌러서 언어 설정해서 PowerShell 등 적고 화면에 보여줄 수 있어(?)
/콜아웃 하면 팁 적을 수 있어.
- + space  --> 글머리 기호
--- --> 구분선 생김


2023-12-12



git init - .git 숨김 파일이 만들어 짐
git add . - .git이라는 모든 파일에 대한 형상을 저장해놓음.
git commit -m "프로젝트 초기화"


